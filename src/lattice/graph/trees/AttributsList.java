/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.trees;// import javaimport java.awt.Color;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Rectangle;/**	* IKBS tools	* Définition de la classe AttributsList, sous classe de ComposantList	* Objet graphique permettant d'afficher une liste d'attributs à un composant	* @author David Grosser	* @date Juillet 1997	* @copyright IREMIA, Université de la Réunion	* @version 2.7**/public class AttributsList extends ComposantList {	protected final static String POINT = "* ";	protected final static String siImage = "|"; // ALT + v	protected Noeud noeud;		// Le noeud qui contient cette liste d'attributs	protected int widthMax=0;	// La largeur de la plus grande chaîne (si AttributeValue)	protected int cl = 5;	protected int ch = 1;	protected int hauteur = 0;// Constructeurs	public AttributsList(Noeud unNoeud) {		super();		setNoeud(unNoeud);		init2();	}// Initialisation	void init2() {		setLabelColor(Color.black);		setBgColor(new Color(210, 210, 210));		setWidth(0);		setHeight(0);	}// Méthodes d'acc?s	public Attribut attribut(int i) {		return (Attribut) liste.elementAt(i);	}	public void setNoeud(Noeud n) {		noeud = n;	}	public void remove(String nom) {		int index = find(nom);		if(index != -1) liste.removeElementAt(index);	}	public int find(String nom) {		for(int i = nbElement() - 1; i>=0; i--)			if(nom == attribut(i).getLabel()) return i;		return -1;	}// fin find	public void setElementAt(Attribut unAttribut, int index) {		liste.setElementAt(unAttribut, index);	}	public Attribut elementName(String nom) {		return (Attribut) liste.elementAt(find(nom)) ;	}// Méthodes	public Object clone(Noeud n) {		AttributsList newList = new AttributsList(n);		for(int i=0; i<nbElement(); i++) {			Attribut att = (Attribut) attribut(i).clone();			att.initNewPere(n);			newList.add(att);		}		return newList;	}/**	* Calcule de la dimension de la liste des attributs*/	public void calculDimension(FontMetrics fm) {	  if(nbElement() != 0) {	  	hauteur = fm.getHeight();		int indexMax = -1;		int maxWidth = 0;		int tempoWidth = 0;		for(int i = 0; i<nbElement(); i++) {			tempoWidth = fm.stringWidth("* " + attribut(i).getLabel());			if (maxWidth < tempoWidth) {				maxWidth = tempoWidth;				indexMax = i;			}		}// fin for		setWidthLabel(maxWidth);		setHeightLabel(hauteur * nbElement());		setWidth(widthLabel()+2*cl);		//setHeight(heightLabel()+ nbElement() * ch + ch + fm.getAscent());		setHeight(heightLabel()+ nbElement() * ch + ch + 3);		widthMax = 0;	  }	}	public Rectangle rect() {		Rectangle r = rect2();		if(widthMax != 0) r.setSize(widthMax + r.width, r.height);		return r;	}	public Rectangle rect2() {		//return new Rectangle(noeud.supGaucheX() + noeud.width()/2, noeud.supGaucheY()+noeud.height(), width()+1, height()+1);		//return new Rectangle(noeud.x(), noeud.infDroitY(), width(), height());		return new Rectangle(noeud.supGaucheX() + noeud.width()/3, noeud.supGaucheY() + noeud.height() - 2, width()+shadowSize.width+1, height()+shadowSize.height+1);	}// Retourne l'attribut a la position (x,y)	public Attribut dansAttributs(int x, int y) {		Attribut unAttribut = null;		if(sourisDans(x, y)) {			unAttribut = rechAttribut(y);		}		return unAttribut;	}/**	* Retourne true si le clic a été effectué dans le composant	* surchargé de Component*/	public boolean sourisDans(int x, int y) {		return rect2().contains(x, y) ;	}	public Attribut rechAttribut(int y) {		for(int i = 0; i<nbElement();i++) {			if(y<y() + ch + hauteur + (ch+hauteur)*i) return attribut(i);		}		return null;	}/**	* Dessine une ombre*/	public void paintShadow(Graphics g, int xRel, int yRel) {		g.setColor(shadow_color);		//g.fillRect(noeud.supGaucheX() + noeud.width()/3 + shadowSize.width +1, noeud.supGaucheY() + noeud.height() - 3 + shadowSize.height+1, width(), height());		g.fillRect(noeud.supGaucheX() + noeud.width()/3 + shadowSize.width - 4, noeud.supGaucheY() + noeud.height() - 3 + shadowSize.height-4, width()+4, height()+4);	}	public void paintValue(Graphics g, Attribut av) {	}/**	* Retourne true si un attribut de la liste est sélectionné*//*	public boolean getSelected() {		boolean b = false;		for(int i=0; i<nbElement(); i++) {			if(attribut(i).getSelected()) b = true;		}		return b;	}*//**	* Dessine la mise en valeur d'un attribut*/	public void paintSelected(Graphics g, int xRel, int yRel, boolean b) {		/*Color c = g.getColor();		g.setColor(c.brighter());*/		g.fillRect(xRel, yRel, width()+4, hauteur+4);		//g.setColor(c);		//g.fillRect(xRel+1, yRel+1, width()+2, hauteur+2);		g.setColor(bgColor());		g.fill3DRect(xRel+2, yRel+2, width(), hauteur, b);		g.setColor(labelColor());	}// Méthode pour dessiner la	liste d'attributs	public void paint(Graphics g) {		FontMetrics fm = g.getFontMetrics();		Rectangle r = rect2();		setPos(r.x, r.y);		//widthMax = 0;		g.setColor(bgColor());		g.fill3DRect(x(), y(), width(), height(), true);		g.setColor(labelColor());		int X = x() + cl ;		//int Y = y() + ch/2 + hauteur;		int Y = y() + hauteur - 1;		String s2 = null;		int l = fm.stringWidth(POINT);		Attribut av;		for(int i=0; i<nbElement(); i++) {			av = attribut(i);			s2 = av.getLabel();			if(av.getSelected()) {				g.setColor(shadow_color);				paintSelected(g, x() - 2 , Y - hauteur+1, ! av.getClicked());			}			if(av.getCible()) {				g.setColor(cible_color);				paintSelected(g, x() - 2, Y- hauteur+1, ! av.getClicked());			}			if(av.getClicked()) {				paintValue(g, av);				g.setColor(av.getColorType());				g.drawString(POINT, X+1, Y+1);			}			else {				paintValue(g, av);				g.drawString(POINT, X+1, Y+1);				g.setColor(attribut(i).getColorType());				g.drawString(POINT, X, Y);				g.setColor(labelColor());			}			g.drawString(s2, X+l, Y);			//g.setColor(labelColor());			Y = Y + hauteur + ch;			//Y = Y + ch;		}	}//fin paint/**	* Pour dessiner la liste d'attributs	* Avec décalage en x et en y*/	public void paint(Graphics g, int xRel, int yRel) {		//if(getSelected()) paintShadow(g, xRel, yRel);		FontMetrics fm = g.getFontMetrics();		//setPos(noeud.supGaucheX() + noeud.width()/2, noeud.supGaucheY() + noeud.height() - 3);		setPos(noeud.supGaucheX() + noeud.width()/3, noeud.supGaucheY() + noeud.height() - 3);		//widthMax = 0;		g.setColor(bgColor());		g.fill3DRect(x()+xRel, y()+yRel, width(), height(), true);		g.setColor(labelColor());		int X = x() + cl + xRel;		int Y = y() + ch/2 + hauteur + yRel;		//int Y = y() + hauteur - yRel;		String s2 = null;		int l2 = 0;		//int l2 = fm.stringWidth(siImage);		int l = fm.stringWidth(POINT);		Attribut av;		for(int i=0; i<nbElement(); i++) {			av = attribut(i);			s2 = av.getLabel();			int nbIllu = av.nbIllustration();			if(nbIllu>0) {				String nIllu = (new Integer(nbIllu)).toString();				l2 = fm.stringWidth(siImage+nIllu);				l2 = fm.stringWidth(nIllu);				g.drawString(nIllu, x() - cl - l2 + xRel, Y  + yRel);			}			if(av.getSelected()) {				g.setColor(shadow_color);				paintSelected(g, x() - 2 + xRel, Y + yRel- hauteur+1, ! av.getClicked());			}			if(av.getCible()) {				g.setColor(cible_color);				paintSelected(g, x() - 2 + xRel, Y + yRel- hauteur+1, ! av.getClicked());			}			if(av.getClicked()) {// Attribut cliqué				paintValue(g, av);				g.setColor(av.getColorType());				g.drawString(POINT, X+1, Y+1);			}			else {// Attribut relevé				g.drawString(POINT, X+1, Y+1);				g.setColor(av.getColorType());				g.drawString(POINT, X, Y);				g.setColor(labelColor());			}			g.drawString(s2, X+l, Y);			//g.setColor(labelColor());			Y = Y + hauteur + ch;		}	}//fin paint}// fin classe AttributsList