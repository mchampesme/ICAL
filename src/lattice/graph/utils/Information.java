/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.utils;import java.awt.Color;import java.awt.Dimension;import java.awt.Font;import java.awt.FontMetrics;import java.awt.Graphics;import java.util.StringTokenizer;import java.util.Vector;/**	* IKBS - Information	* DŽfinition de Information, sous classe de Object	* David Grosser - 12 dŽcembre 1999	* Version 2.6	* @author David Grosser	* Permet de gŽrer l'affichage de l'information dans la fen?tre GraphViewer*/public class Information extends Object {// L'alignement du paragraphe, les constantes	public static final int LEFT = 0;	public static final int RIGHT = 1;	public static final int CENTER = 2;	public static final int UP = 0;	public static final int BOTTOM = 1;// La couleur d'affichage du texte	public Color bgColor = Color.black;	public Color fgColor = Color.white;// La cha”ne ˆ afficher (Žventuellement sur plusieurs lignes)	protected String info;	protected Vector vInfo;// Le vecteur contenant l'info, mais un Žlement par ligne de type String	protected int indexMax;// Index de la plus large ligne	protected int position = LEFT;	protected int vAlign = BOTTOM;	protected int alignType = LEFT; // Le type d'alignement choisit	protected boolean cadre = true;	protected boolean affInfo = false;	protected boolean firstLineBold = false;	protected boolean outlined = true; // Texte entourŽ de la couleur contraire// Constructeurs	public Information(String info) {		this.info = info;		initVInfo();	}	public Information(String info, int align) {		this(info);		this.alignType = align;	}	public Information(String info, int align, int vAlign) {		this(info);		this.alignType = align;		this.vAlign = vAlign;	}	public Information(String info, int align, int vAlign, Color bg, Color fg) {		this(info, align, vAlign);		this.bgColor = bg;		this.fgColor = fg;	}	public Information(String info, int align, int vAlign, Color bg, Color fg, boolean outlined) {		this(info, align, vAlign, bg, fg);		this.outlined = outlined;	}/**	* MŽthode d'affectation au champ info*/	public void setInfo(String s) {		this.info = s;		if(s.equals("")) vInfo = null;		else initVInfo();	}/**	* Affectation de la position d'alignement*/	public void setAlignType(int a) {		this.alignType = a;	}/**	* Affectation de la position d'alignement*/	public void setPosition(int a) {		this.position = a;	}	public void setvAlign(int a) {		this.vAlign = a;	}	public void setFirstLineBold(boolean b) {		firstLineBold = b;	}/**	* Initialisation de vInfo, de la largeur de la plus large ligne et de la hauteur d'une ligne*/	protected void initVInfo() {		int w = 0;		indexMax = 0;		vInfo = new Vector();		StringTokenizer st = new StringTokenizer(info, "\n");		int i = 0;		String s = null;		while(st.hasMoreTokens()) {			s = st.nextToken();			if(s != null) {				//System.out.println(s);				vInfo.addElement(s);				int wCourant = s.length();				if (wCourant>w) {w = wCourant; indexMax = i;}				i++;			}		}		if(i == 0) vInfo = null;		//System.out.println("Chaine la plus longue : "+vInfo.elementAt(indexMax)+" ˆ l'index : "+indexMax);	}	public String getInfo() {		return info;	}	public void setAffInfo(boolean b) {		this.affInfo = b;	}	public boolean getOutlined() {		return outlined;	}	public void setOutlined(boolean b) {		this.outlined = b;	}	public boolean getAffInfo() {		return affInfo;	}	public void paint(Graphics g, Dimension d, Font f) {		if(affInfo) {			if((info != null)&&(vInfo != null)) {				//if(f == null)				f = new Font("Geneva", Font.PLAIN, 12);				FontMetrics fm = g.getFontMetrics(f);				int wMax = fm.stringWidth((String) vInfo.elementAt(indexMax));				int h = fm.getHeight();				g.setColor(bgColor);				g.setFont(f);				int posX = 0;				/*if(cadre) {					Rectangle3D r = null;					if(alignType == LEFT_ALIGNED) r = new Rectangle3D(Color.yellow, 5, h-5, wMax+5, h*(vInfo.size()+2));					if(alignType == RIGHT_ALIGNED) r = new Rectangle3D(Color.yellow, d.width-5, h-5, wMax+5, h*(vInfo.size()+1));					if(alignType == CENTER_ALIGNED) r = new Rectangle3D(Color.yellow, d.width-5, h-5, wMax+5, h*(vInfo.size()+1));					r.paint(g);				}*/				int posY;				if(vAlign == UP) posY = 5;				else posY = d.height - h*(vInfo.size()+1);				for(int i=0; i<vInfo.size(); i++) {					if(firstLineBold) {						if(i == 0) {							f = new Font("Geneva", Font.BOLD, 14);							fm = g.getFontMetrics(f);							g.setFont(f);						}						else						if(i == 1) {							f = new Font("Geneva", Font.PLAIN, 12);							fm = g.getFontMetrics(f);							g.setFont(f);						}					}					int w = fm.stringWidth((String) vInfo.elementAt(i));					switch(position) {						case LEFT: posX = 10; break;						case RIGHT: posX = d.width-wMax-10; break;						case CENTER: posX = (d.width-w)/2; break;						default: posX = 10; break;					}					switch(alignType) {						case LEFT: posX = posX+0; break;						case RIGHT: posX = d.width - 10 - w; break;						case CENTER: posX = posX+(wMax-w)/2; break;						default : break;					}					if(outlined) {						g.setColor(bgColor);						g.drawString((String) vInfo.elementAt(i), posX+1, posY+h*(i+1));						g.drawString((String) vInfo.elementAt(i), posX-1, posY+h*(i+1));						g.drawString((String) vInfo.elementAt(i), posX, posY+h*(i+1)+1);						g.drawString((String) vInfo.elementAt(i), posX, posY+h*(i+1)-1);					}					g.setColor(fgColor);					g.drawString((String) vInfo.elementAt(i), posX, posY+h*(i+1));					//System.out.println("info");				}			}		}	}}