/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.trees;import java.awt.Color;import java.awt.Dimension;import java.awt.Font;import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.Point;import java.awt.Rectangle;import java.util.Enumeration;import java.util.Observable;import java.util.Observer;import java.util.Vector;import javax.swing.JPanel;import lattice.graph.trees.formatter.Formatter;import lattice.graph.trees.formatter.FormatterGD;import lattice.graph.trees.formatter.FormatterGD2;import lattice.graph.trees.formatter.FormatterGD3;import lattice.graph.trees.formatter.FormatterGD4;import lattice.graph.trees.formatter.FormatterGD5;import lattice.graph.trees.formatter.FormatterHB;import lattice.graph.utils.GetFrame;import lattice.graph.utils.Information;import lattice.graph.zoom.ZoomViewer;/**	* IKBS - Panel d'affichage des arbres (sans action)	* Class GraphViewer : Panel générique pour la gestion et le formattage de graphe	* Définition de GraphViewer, sous classe de Canvas	* David Grosser - 28 Aout 1997	* @since 12/12/99	* Version 2.6	* @author David Grosser	* Cette classe g?re l'affichage des arbres, le fond, etc.*/public class GraphViewer extends JPanel implements GetFrame, Observer {// Les méthodes de formattage	public static final int FORMATTER_GD  = 0;	public static final int FORMATTER_GD2 = 1;	public static final int FORMATTER_GD3 = 2;	public static final int FORMATTER_GD4 = 3;	public static final int FORMATTER_GD5 = 4;	public static final int FORMATTER_HB  = 5; // Attention, pas de gestion des cycle	// Les différents modes de dessins des élements	public static final int NORMAL = 0; // Mode par défaut, on ne dessine les élements que dans la vue réelle	public static final int OFFSCREEN = 1; // On dessine dans un autre rep?re (utilisé par exemple pour l'image réduite de l'arbre	public static Image backgroundPicture = null;	public static final int BG_REPEAT = 0;	public static final int BG_CENTER = 1;	public static final int BG_FITTED = 2;	public static final int BG_LEFT   = 3;	public static final int BG_NONE   = 4;	public static final int BG_BOTTOM = 5;	public static final int BG_GRILLE = 6;// Les variables d'instance pour la gestion des coordonnées graphiques du canvas	protected int x, y;						// Déplacement relatif des composants du canvas	protected Point pos;					// Position du clic souris// Les variables d'instance pour la gestion des objets et des relations	public Vector noeuds = new Vector() ; 	// La liste des noeuds	protected Noeud noeudSelect ;				// Le noeud selectionne	public Noeud noeudRacine ;				// Le noeud racine	protected RelationSelect relationSelect ;	// La relation en cours de creation	protected boolean select, relationMode, shiftPressed;// Les differents flags// Les variables d'instance pour la gestion de l'affichage	protected int zoom ;				// La taille du zoom        protected int formeRelation;			// formeRelation=1 : lignes droites, formeRelation=2 : lignes brisées	protected String policeObj="Geneva";		// La police courante pour afficher les noeuds	protected String policeAtt="Geneva";		// La police courante pour afficher les attributs	protected String policeRel="Geneva";		// La police courante pour afficher les relations	protected int styleObj 	= Font.PLAIN;				// La police courante pour afficher les noeuds	protected int styleAtt = Font.PLAIN;				// La police courante pour afficher les attributs	protected int styleRel= Font.ITALIC;				// La police courante pour afficher les relations	protected Font fontObj, fontAtt, fontRel;	protected Rectangle rect;					// Pour la gestion de la zone à rafraichir	protected int bgAlignment = BG_NONE;// Variables d'état   	protected boolean drag = false;				// gestion du mode drag	protected boolean painted = true;			// Permet de tester que la derni?re requ?te de dessin a bien été effectuée	protected boolean shadow = false;			// Pour afficher une ombre aux composants	protected boolean paintInfo = true;			// Doit on dessiner l'info ?	protected boolean active = true;			// Doit-on dessiner les fl?ches d'expansion/masquage des fils ?	protected boolean showArrow = false;		// showArrow = true : relations avec fl?ches, showArrow = false : on masque les fl?ches	protected boolean affAttributs;				// Si true, on affiche les attributs des noeuds	protected boolean showLabelRelation;		// Affichage du label des relations	protected int posLien = 0; // Position des relations : 0 = horizontales, 1 = verticales// Les variables d'instance pour le formattage	protected Formatter formatter;					// Choix de la méthode de formattage à appliquer// Le canvas de zoom	protected ZoomViewer zoomCanvas;// La zone de texte à afficher	protected Information info = new Information("", Information.LEFT, Information.UP, Color.white, Color.black, false);/************************ Les constructeurs ************************/	public GraphViewer() {		init();	}	public GraphViewer(Vector n) {		init() ;		setNoeuds(n) ;		//setRelations(r) ;	}/********************* Initialisation *********************/// Initialisation des variables d'instances	public void init() {		formatter  = new FormatterGD4(noeuds);		setX(0);		setY(0);		setZoom(9);		initFont(getZoom());		//cl = 8;					// Contrainte de positionnement de l'arbre en largeur		//ch = 4;						// Contrainte de positionnement de l'arbre en hauteur		pos = new Point(0, 0);		select = false ;			// aucun noeud selectionne		relationMode = false ;		// on n'est pas en mode relation		setBackground(Color.white) ;// couleur du fond blanche		noeudRacine = null ; 		// pas de noeud racine		//formeRelation = 2;		shiftPressed = false;		affAttributs = false;		//fm = posFont(zoom);		// positionnement de la fonte / zoom		showArrow = false;			// on ne montre pas les fl?ches		drag = false ;				// pas de mode drag de la souris		showLabelRelation = false;		formeRelation = Relation.FORME_ESCALIER; // formeRelation=1 : lignes droites, formeRelation=2 : lignes brisées	}/*************************************************************** Les méthodes d'acc?s aux param?tres graphiques du canvas ***************************************************************/// Gestion de la position et de la taille du canvas	public void setPosClic(int x, int y) {pos.x = x; pos.y = y;}	public int getX() { return x; }	public void setX(int x) {this.x=x;}	public int getY() { return y; }	public void setY(int y) {this.y = y;}	public Rectangle rect() {		return rect;	}	public void setRect(Rectangle r) {rect = r;}	public void addRect(Rectangle r) {		if(rect != null) rect.add(r);		else setRect(r);	}	public void setZoom(int zoom) {		this.zoom = zoom;		if(formatter != null) formatter.setZoom(zoom);	}	public int getZoom() {		return zoom;	}	public int getPosX() {		return pos.x;	}	public int getPosY() {		return pos.y;	}	public void setPosX(int x) {		pos.x = x;	}	public void setPosY(int y) {		pos.y = y;	}// implémente GetFrame	public Frame getFrame() {		return ((GetFrame) getParent()).getFrame();	}	public void setZoomViewer(ZoomViewer zc) {		zoomCanvas = zc;	}	public ZoomViewer zoomCanvas() {		return zoomCanvas;	}	public void setInfo(String s) {		this.info.setInfo(s);	}	public String getInfo() {		return info.getInfo();	}/**	* Affectation de la variable noeudSelect*/	public void setNoeudSelect(Noeud s) {		this.noeudSelect = s;	}/**	* Acc?s à la variable noeudSelect*/	public Noeud getNoeudSelect() {		return noeudSelect;	}	//public Font fm() {return fm;}/*************************************************************** Les méthodes d'acc?s aux composants du canvas 			***************************************************************/	protected int nbNoeuds() {		return noeuds.size();	}	protected Vector noeuds() {		return noeuds;	}	protected void setNoeuds(Vector n) {		noeuds = n ;	}	public Noeud noeuds(int i) {		return (Noeud) noeuds.elementAt(i) ;	}        public boolean getShowArrow() {          return showArrow;        }	public void setShowArrow(boolean b) {		showArrow = b;		for(int i = 0; i<noeuds().size(); i++) {			noeuds(i).setShowArrow(b);		}		repaint();	}/***************************************** Les méthodes pour gérer les noeuds *****************************************/	// Ajouter un noeud	public int ajouterNoeud(Noeud unNoeud) {		noeuds.addElement(unNoeud);		unNoeud.addObserver((Observer) this);		return noeuds.size();	}	public Noeud creerNoeud(int x, int y) {		Noeud unNoeud = new NodeGraph(new Point(x, y));		calculDimension(unNoeud);		unNoeud.setActiveNode(active);		return unNoeud;	}	public Noeud creerNoeud(String s, int x, int y) {		Noeud unNoeud = new NodeGraph(s, new Point(x, y));		calculDimension(unNoeud);		unNoeud.setActiveNode(active);		return unNoeud;	}	public Noeud creerNoeud(String s) {		Noeud unNoeud;		int rech = rechNoeud(s);		if (rech == -1) {			unNoeud = creerNoeud(s, 30, 20);			ajouterNoeud(unNoeud);			return unNoeud;		}		else return noeuds(rech);	}/*	* Cette méthode doit ?tre surchargée lorsque l'on souhaite déclencher un action	* d'édition sur un noeud de l'arbre*/	public void editer(Noeud n) {		//System.out.println("Edition du noeud "+n.getLabel());	}/*	* Cette méthode doit ?tre surchargée lorsque l'on souhaite déclencher un action	* d'édition sur un attribut d'un noeud*/	public void editer(Attribut a, Noeud n) {	}/**	* Pour calculer la dimension d'un noeud*/	public void calculDimension(Noeud n) {		n.calculDimension(	getFontMetrics(new Font(policeObj, styleObj, getZoom())),							getFontMetrics(new Font(policeAtt, styleAtt, getZoom())),							getFontMetrics(new Font(policeRel, styleRel, getZoom())));	}	public void calculDimensionObj(Noeud n) {		n.calculDimensionObj(getFontMetrics(new Font(policeObj, styleObj, getZoom())));	}/**	* Pour calculer la dimension de la liste d'attributs d'un noeud*/	public void calculDimensionAtt(Noeud n) {		n.calculDimensionAtt(getFontMetrics(fontAtt));	}/**	* Pour calculer la dimension des relations d'un noeud*/	public void calculDimensionRel(Noeud n) {		n.calculDimensionRel(getFontMetrics(fontRel));	}/**	* Pour calculer la dimension d'une relation*/	public void calculDimension(Relation r) {		r.calculDimension(getFontMetrics(fontRel));	}/**	* Pour recalculer la dimension de tous les noeuds*/	public void reCalculDimension() {		for(int i=0; i<noeuds.size(); i++) {			if(fontObj == null) System.out.println("fontObj est null");			if(fontAtt == null) System.out.println("fontAtt est null");			if(fontRel == null) System.out.println("fontRel est null");			noeuds(i).calculDimension(	getFontMetrics(fontObj),										getFontMetrics(fontAtt),										getFontMetrics(fontRel));		}	}/**	* Acc?s à la racine de l'arbre*/	public Noeud noeudRacine() {		return noeudRacine;	}/**	* Elimine l'ancienne racine et positionne la nouvelle racine*/	public void setRacine(Noeud unNoeud) {		if(unNoeud != null) unNoeud.setRacine(true);		if(noeudRacine != null) noeudRacine.setRacine(false);		noeudRacine = unNoeud;	}	public Noeud creerNoeudRacine(String s) {		int rech = rechNoeud(s);		if (rech == -1) {			Noeud r = creerNoeud(s, getBounds().x/2, getBounds().y/2);			setRacine(r);			ajouterNoeud(r);			return r;		}		else return noeuds(rech);	}	public void initRelation(Relation r) {		r.setForme(formeRelation);		if(showLabelRelation)			r.showLabel();		else r.hideLabel();		r.setPosLien(posLien);		r.setShowArrow(showArrow);		calculDimension(r);	}	public int indexOf(Noeud unNoeud) {		for(int i = 0; i<noeuds.size(); i++)			if (noeuds(i) == unNoeud)  return i;		return 0;	}	public void effacerNoeud(int index) {		//System.out.println("On efface le noeud a l'index "+index);		Noeud unNoeud = noeuds(index);		/*for(int i=0; i < unNoeud.relationArrive().size(); i++) {			Relation r = ((Relation) unNoeud.relationArrive(i));			r.origine().removeRelationDepart(r);		}*/		unNoeud.removeRelations();		noeuds.removeElementAt(index);	}	public void effacerNoeud(Noeud unNoeud) {		effacerNoeud(indexOf(unNoeud));	}/*	public void effacerRelations(Noeud unNoeud) {		for(int i=0; i < unNoeud.relationArrive().size(); i++) {			Relation r = ((Relation) unNoeud.relationArrive(i));			r.origine().removeRelationDepart(r);		}	}*//**	* Effacement de tous les relations entre unNoeud et ses p?res*/	/*public void effacerNoeudRec(Noeud unNoeud) {	//System.out.println("GraphViewer : effacerNoeudRec "+unNoeud);		/*for(int i=0; i < unNoeud.relationArrive().size(); i++) {			Relation r = ((Relation) unNoeud.relationArrive(i));			//System.out.println("GraphViewer : effacerNoeudRec "+r);			r.origine().removeRelationDepart(r);		}*/		//effacerNoeudsRec(unNoeud);	//}*//**	* Effacement de tous les noeuds fils récursivement*/	public void effacerNoeudsRec(Noeud unNoeud) {		Vector fils = unNoeud.fils();		for (Enumeration e = fils.elements(); e.hasMoreElements();) {			effacerNoeudsRec((Noeud) e.nextElement());		}		//effacerRelations(unNoeud);		effacerNoeud(unNoeud);	}/**	* Retourne l'index du noeud cliqué. -1 si on ne clic pas sur un noeud*/	public int rechNoeud(int x, int y) {		for(int i=noeuds.size() - 1; i>=0; i--) {			if(noeuds(i).sourisDans(x, y)) return i;		}		return -1;	}	public int rechNoeud(String s) {		for(int i=0; i<noeuds.size(); i++)			if(s.compareTo(noeuds(i).getLabel()) == 0) return i;		return -1;	}/**	* Deplacer le sous arbre de racine unNoeud*/	public void bougeNoeudRec(Noeud unNoeud, int dx, int dy) {		demarquer2();		bougeNoeudRecs(unNoeud, dx, dy);	}	// Deplacer le sous arbre de racine unNoeud (recursif)	public void bougeNoeudRecs(Noeud unNoeud, int dx, int dy) {		Vector fils = unNoeud.fils();		if(! unNoeud.getMarque2()) {			unNoeud.setMarque2(true);			//if(rect == null) rect = unNoeud.rectRels();			//else rect.add(unNoeud.rectRels());			unNoeud.bouge(dx, dy);			//rect.add(unNoeud.rectRels());			for(int i=0; i<fils.size(); i++)			bougeNoeudRecs((Noeud)fils.elementAt(i), dx, dy);		}//fin if	}	// Deplacer un noeud	public void bougeNoeud(Noeud unNoeud, int dx, int dy) {		setRect(unNoeud.rectRels());		unNoeud.bouge(dx, dy);		addRect(unNoeud.rectRels());		repaint();	}/**	* Positionne le noeud @param en derni?re position*/	public void putLastPosition(Noeud unNoeud) {		int index = indexOf(unNoeud);		noeuds().removeElementAt(index);		//effacerNoeud(unNoeud);		ajouterNoeud(unNoeud);	} // fin putLastPosition/**	* Gestion du premier marqueur (pour éviter les cycles lors d'un parcours récursif)*/	protected void marquer() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque(true);	}/**	* Demarquer tous les noeuds*/	protected void demarquer() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque(false);	}// Gestion du deuxi?me marqueur	(pour éviter les cycles lors d'un parcours récursif)	protected void marquer2() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque2(true);	}	protected void demarquer2() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque2(false);	}/******************************************** Les méthodes pour gerer les relations ********************************************/	/*public Relation creerRelation(String label, Noeud origine, Noeud extremite) {		Relation uneRelation = new Relation(origine, extremite, label);		if(uneRelation != null) calculDimension(uneRelation);		return uneRelation;	}	public Relation creerRelation(Noeud origine, Noeud extremite) {		Relation uneRelation = new Relation(origine, extremite);		if(uneRelation != null) calculDimension(uneRelation);		return uneRelation;	}*//*	public void creerRelation(String s1, String s2) {		int n1 = rechNoeud(s1) ;		int n2 = rechNoeud(s2) ;		if ((n1 != -1) && (n2 != -1))			ajouterRelation(creerRelation(noeuds(n1), noeuds(n2))) ;	}*/	// Edition des relations/*	public void editer(Relation r) {	}*/	// Le nettoyage des relations d'un noeud	/*public void effacerRelations(Noeud unNoeud) {		Vector fils = fils(unNoeud);		Vector peres = peres(unNoeud);		for(int i = 0; i<fils.size(); i++) {			((Noeud) fils.elementAt(i)).removeRelationArrive(unNoeud);		}		for(int i = 0; i<peres.size(); i++) {			((Noeud) peres.elementAt(i)).removeRelationDepart(unNoeud);		}		for(int i = 0; i<relations.size();) {			if(relations(i).lieA(unNoeud)) {				unNoeud.removeRelation(relations(i));				relations.removeElementAt(i);			}			else i++;		}// fin for	}*/	// Creer puis ajouter une relation (sans label)	/*public void creerAjouterRelation(Noeud origine, Noeud extremite) {		Relation r = creerRelation(origine, extremite);		if(r != null) ajouterRelation(r);	}*/	// Creer puis ajouter une relation (avec label)	/*public void creerAjouterRelation(String label, Noeud origine, Noeud extremite) {		Relation r = creerRelation(label, origine, extremite);		if (r != null) ajouterRelation(r);	}*/	// Effacer une relation	/*public void effacerRelation(int i) {		effacerRelation(relations(i));		//(relations(i).origine()).removeRelation(relation(i));		//(relations(i).extremite()).removeRelation(relation(i));		relations.removeElementAt(i) ;	}*/	/*public void effacerRelation(Relation r) {		r.origine().removeRelationDepart(r);		r.extremite().removeRelationArrive(r);		relations.removeElement(r) ;	}*/	// On retourne la relation, si elle est la seule a etre dans le rectangle	/*public int rechRelation(int x, int y) {		int nb = 0;		int j = 0;		for(int i=relations.size() - 1; i>=0; i--) {			if(relations(i).sourisDans(x, y)) {				j=i;				nb++;			}		}		if (nb == 1) return j;		else return -1;	}*/	public void changeFormeRelation(int forme) {		this.formeRelation = forme;		for(int i=0; i<noeuds().size(); i++) {			noeuds(i).changeFormeRelation(forme);		}		repaint();	}// fin changeFormeRelation	// Afficher les etiquettes des relations	public void activeTextRelations() {		this.showLabelRelation = true;		for(int i=0; i<noeuds.size(); i++)			noeuds(i).showLabelRelations(true);		repaint();	}	// Desactiver l'affichage des etiquettes de relations	public void desactiveTextRelations() {		this.showLabelRelation = false;		for(int i=0; i<noeuds.size(); i++)			noeuds(i).showLabelRelations(false);		repaint();	}	public void afficherInfo(boolean b) {		info.setAffInfo(b);	}	// Positionnement vertical ou horizontal des relations	public void posLienRelations(int pos) {		if(posLien != pos) {			posLien = pos;			for(int i=0; i<noeuds.size(); i++)				noeuds(i).setPosLien(pos);			repaint();		}	}/**	* Affichage ou masquage des fils d'un noeud*/	public void affSousArbre(Noeud unNoeud, boolean aff) {		Vector fils = unNoeud.fils();		unNoeud.setMarque(true);		for(int i=0; i<fils.size(); i++) {			Noeud unFils = (Noeud) fils.elementAt(i);			if(! unFils.getMarque()) affSousArbreRec(unFils, aff);		}		formatter3(unNoeud);	}/**	* Affichage ou masquage récursif des fils d'un noeud*/	public void affSousArbreRec(Noeud unNoeud, boolean aff) {		unNoeud.setMarque(true);		unNoeud.setVisible(aff);		Vector fils = unNoeud.fils();		for(int i=0; i<fils.size(); i++) {			Noeud unFils = (Noeud) fils.elementAt(i);			if(! unFils.getMarque()) affSousArbreRec(unFils, aff);		}	}/******************************************** Les méthodes pour gerer les attributs ********************************************/	public void affAttributs(boolean aff) {		affAttributs = aff;		for(int i = 0 ; i<noeuds.size() ; i++) noeuds(i).setAffAttributs(aff);		formatter();	}	public void changeAffAttributs(Noeud n, boolean aff) {		n.setAffAttributs(aff);		formatter2();	}/***************************************/* Les methodes pour afficher l'arbre *****************************************/// Changer la couleur du fond des noeuds	public void changeBgColor(Color c) {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setBgColor(c);		repaint();	}// Changer la couleur du fond des attributs	public void changeBgColorAtt(Color c) {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setBgColorAtt(c);		repaint();	}// Changer la couleur du texte des noeuds	public void changeLabelColor(Color c) {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setLabelColor(c);		repaint();	}// Changer la couleur du texte des attributs	public void changeLabelColorAtt(Color c) {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setLabelColorAtt(c);		repaint();	}// Positionner la fonte des noeuds	public void setPoliceObj(String p) {		policeObj = p;		fontObj = new Font(policeObj, styleObj, getZoom());		for(int i=0; i<noeuds.size(); i++) calculDimensionObj(noeuds(i));		formatter2();	}// Positionner le style de la fonte des noeuds	public void setStyleObj(int p) {		styleObj = p;		fontObj = new Font(policeObj, styleObj, getZoom());		for(int i=0; i<noeuds.size(); i++) calculDimensionObj(noeuds(i));		formatter2();	}// Positionner la fonte des attributs	public void setPoliceAtt(String p) {		policeAtt = p;		fontAtt = new Font(policeAtt, styleAtt, getZoom());		for(int i=0; i<noeuds.size(); i++) calculDimensionAtt(noeuds(i));		formatter2();	}// Positionner le style de la fonte des noeuds	public void setStyleAtt(int p) {		styleAtt = p;		fontAtt = new Font(policeAtt, styleAtt, getZoom());		for(int i=0; i<noeuds.size(); i++) calculDimensionAtt(noeuds(i));		formatter2();	}// Positionner la fonte des relations	public void setPoliceRel(String p) {		policeRel = p;		fontRel = new Font(policeRel, styleRel, getZoom());		for(int i=0; i<noeuds.size(); i++) calculDimensionRel(noeuds(i));		formatter2();	}// Positionner le style de la fonte des relations	public void setStyleRel(int p) {		styleRel = p;		fontRel = new Font(policeRel, styleRel, getZoom());		for(int i=0; i<noeuds.size(); i++) calculDimensionRel(noeuds(i));		formatter2();	}// Zoom positif (on agrandit)	public synchronized void ZP() {		if(painted) {			int pas = 1;			if(zoom > 15) pas = 2;			if(zoom > 20) pas = 3;			if(zoom > 30) pas = 5;			if(zoom > 120) zoom = 120;			else zoom += pas;			initFont(getZoom());			reCalculDimension();                        if(formatter != null) formatter.setZoom(zoom);			formatter2();                        System.out.println(zoom);		}	}// Zoom négatif (on rétrécit)	public synchronized void ZM() {		if(painted) {			int pas = 1;			if(zoom < 120) pas = 5;			if(zoom < 30) pas = 3;			if(zoom < 20) pas = 2;			if(zoom < 15) pas = 1;			if(zoom < 6) zoom = 5;			else zoom -= pas;			initFont(getZoom());			reCalculDimension();                        if(formatter != null) formatter.setZoom(zoom);			formatter2();                        System.out.println(zoom);		}	}// La largeur maximale du canvas = la coordonnées X la plus à droite du noeud le plus à droite	int maxWidth() {		int maxWidth = 0;		for (Enumeration e = noeuds.elements(); e.hasMoreElements();) {           Noeud unNoeud = (Noeud) e.nextElement();           //if(unNoeud.infDroitX()>maxWidth) maxWidth = unNoeud.infDroitX();           int w = unNoeud.rect().width + unNoeud.supGaucheX();           if(w>maxWidth) maxWidth = w;		}		return maxWidth;	}// La hauteur maximale du canvas = la coordonnées Y la plus en bas du noeud le plus en bas	int maxHeight() {		int maxHeight = 0;		for (Enumeration e = noeuds.elements(); e.hasMoreElements();) {           Noeud unNoeud = (Noeud) e.nextElement();           int h = unNoeud.rect().height + unNoeud.supGaucheY() ;           if (h>maxHeight) maxHeight = h;		}		return maxHeight;	}/**	* Le rectangle englobant de tous les noeuds*/	public Rectangle dimension() {		int x1, y1, x2, y2;		if(noeuds.size() > 0) {			Noeud n = noeuds(0);			x1 = n.supGaucheX();			y1 = n.supGaucheY();			x2 = n.infDroitX() + n.rect().width;			y2 = n.infDroitY() + n.rect().height;			for (Enumeration e = noeuds.elements(); e.hasMoreElements();) {				n = (Noeud) e.nextElement();                                x1 = Math.min(n.supGaucheX(), x1);                                x2 = Math.max(n.infDroitX()+n.rect().width, x2);                                y1 = Math.min(n.supGaucheY(), y1);                                y2 = Math.max(n.infDroitY()+n.rect().height, y2);			}			//return new Rectangle(x1-10-getX(), y1-10-getY(), x2 - x1+20, y2 - y1+20);                        return new Rectangle(x1-getX(), y1-getY(), x2 - x1, y2 - y1);		}		return null;	}/**	* Initialisation des fontes des objets, des attributs et des relations*/	public void initFont(int zoom) {		fontObj = new Font(policeObj, styleObj, zoom);		fontAtt = new Font(policeAtt, styleAtt, zoom);		fontRel = new Font(policeRel, styleRel, zoom);	}/***********************Gestion de l'affichage *************************//*** Méthode utilisée pour dessiner l'arbre (la portion comprise dans rect) aux coordonnées relatives (xRel, yRel)*/	public synchronized void paint(Graphics g) {		rect = getBounds();		paintBackground(g);                if((zoomCanvas != null)&&(! zoomCanvas.getQualite()))                  zoomCanvas.repaint();                //synchronized(this) {                  paint(g, rect);                //}	  	painted = true;	}/*** Dessin en mode offscreen sans modification d'échelle*/        public synchronized void paintOffscreen(Graphics g, Rectangle rect) {          initFont(getZoom());          Noeud noeudCourant;          g.setFont(fontRel);          for (int i=0; i<noeuds.size(); i++) {            noeuds(i).paintRelations(g, -rect.x, -rect.y);          }          g.setFont(fontObj);          for (int i=0; i<noeuds.size(); i++) {            noeudCourant=noeuds(i);            if((noeudCourant.dansRect(rect))&&(noeudCourant.visible())) {              g.setFont(fontObj);              noeudCourant.paint(g, -rect.x, -rect.y);              g.setFont(fontAtt);              noeudCourant.paintAtt(g, -rect.x, -rect.y);              zoomCanvas.setZoomPainted(true);            }          }        }// dessin en mode offscreen, utilisé par le zoom        public synchronized void paintOffscreen(Graphics g, int x, int y, float factor) {          Noeud n = null;          Noeud n2 = null;          Color nodeColor = new Color(160, 160, 160);          //g.setFont(new Font(policeObj, styleObj, 4));          float decX, decY, decX2, decY2;          for (int i=0; i<noeuds.size(); i++) {            n = noeuds(i);            decX = (n.x() - x)/factor;            decY = (n.y() - y)/factor;              for(int j=0; j<n.relationDepart().size(); j++) {                g.setColor(n.relationDepart(j).bgColor().brighter());                n2 = n.relationDepart(j).extremite();                decX2 = (n2.x() - x)/factor;                decY2 = (n2.y() - y)/factor;                g.drawLine(Math.round(decX), Math.round(decY), Math.round(decX2), Math.round(decY2));              }              g.setColor(n.bgColor().darker());              float nodeWidth = n.width()/factor;              float nodeHeight = n.height()/factor;              g.fillOval(Math.round(decX-(nodeWidth/2f)), Math.round(decY-(nodeHeight/2f)), Math.round(nodeWidth), Math.round(nodeHeight));              //g.setColor(bgColor().darker());              //g.drawOval(supGaucheX()+xRel, supGaucheY()+yRel-1, width(), height());              //g.drawString(n.getLabel(), decX, decY);          }        }/**	* Dessiner les composants aux coordonnées réelles*/        public void paint(Graphics g, Rectangle rect) {          Noeud noeudCourant;          g.setFont(fontRel);          for (int i=0; i<noeuds.size(); i++) noeuds(i).paintRelations(g, getX(), getY());          g.setFont(fontObj);          for (int i=0; i<noeuds.size(); i++) {            noeudCourant=noeuds(i);            noeudCourant.bouge(getX(), getY());            //if((noeuds(i).dansRect(rect))&&(noeudCourant.visible())) {            //if(shadow) {            //	noeudCourant.paintShadow(g, 0, 0);            //	noeudCourant.paintAttShadow(g, 0, 0);            //}            //g.setFont(fontObj);            noeudCourant.paint(g, 0, 0);            //g.setFont(fontAtt);            noeudCourant.paintAtt(g, 0, 0);            //}          } // fin boucle for noeuds          if (relationSelect != null) {            //if(formeRelation == 1) relationSelect.paint(g, showArrow);            relationSelect.paint(g, 0, 0);          } // fin if          setX(0);// Remise à 0 du décalage relatif en x des noeuds          setY(0);// Remise à 0 du décalage relatif en y des noeuds          this.rect = null; // Remise à 0 du rectangle de rafraichissement        }// Fin paint	public static void setBackgroundPicture(Image img) {		backgroundPicture = img;	}/**	* retourne l'image à dessiner au fond*/	public static Image getBackgroundPicture(Image img) {		return backgroundPicture;	}/**	* dessine le fond de l'écran*/        public void paintBackground(Graphics g) {          Dimension d = getSize();          g.setColor(getBackground());          g.setClip(rect.x, rect.y, rect.width, rect.height);          g.fillRect(rect.x, rect.y, rect.width, rect.height);          if(backgroundPicture != null) {            switch (bgAlignment) {              //if(bgAlignment == BG_NONE) {}              case BG_LEFT: g.drawImage(backgroundPicture, 0, 0, this); break;// en papier peind              case BG_BOTTOM: g.drawImage(backgroundPicture, 0, d.height-backgroundPicture.getHeight(this), this); break;// en papier peind              case BG_REPEAT:                for(int x = 0; x<d.width; x += backgroundPicture.getWidth(this)) {                  for(int y = 0; y<d.height; y+= backgroundPicture.getHeight(this))                    g.drawImage(backgroundPicture, x, y, this); // en papier peind                }                break;              case BG_FITTED:                g.drawImage(backgroundPicture, 0, 0, d.width, d.height, this); // Retaillé selon la taille de la fen?tre                break;              case BG_CENTER:                int x = (d.width-backgroundPicture.getWidth(this))/2;                int y = (d.height-backgroundPicture.getHeight(this))/2;                g.drawImage(backgroundPicture, x, y, this); // Retaillé selon la taille de la fen?tre                break;              case BG_GRILLE:                g.setColor(Color.lightGray);                int gapX = zoom*3;                int gapY = zoom*3;                for(int i=0; i<d.height; i+=gapX) {                  g.drawLine(0, i, d.width, i);                }                for(int j=0; j<d.width; j+=gapY) {                  g.drawLine(j, 0, j, d.height);                }                break;              default: break;            }          }          if((info != null)&&(paintInfo)) info.paint(g, d, new Font(policeObj, styleObj, getZoom()));        }	public void setBgAlignment(String salign) {		//System.out.println(salign);		if(salign.equals("Motif")) bgAlignment = BG_REPEAT;		if(salign.equals("Centrer")) bgAlignment = BG_CENTER;		if(salign.equals("Adapter")) bgAlignment = BG_FITTED;		if(salign.equals("Gauche")) bgAlignment = BG_LEFT;		if(salign.equals("Aucun")) bgAlignment = BG_NONE;		if(salign.equals("Bas")) bgAlignment = BG_BOTTOM;		if(salign.equals("Grille")) bgAlignment = BG_GRILLE;		repaint();	}/**	* Méthode surchargée*/	public void drawZoom(Graphics g, Dimension d) {		if(drag)		   	if(zoomCanvas != null)			zoomCanvas.setRect(new Rectangle(-getX(), -getY(), d.width, d.height));	}	public void setRect(Noeud n) {		rect = n.rect() ;	}/**	* Affectation de la zone à rafraichir*/	public void setRect(Relation r) {		rect = r.rect();	}/*	* Permet de recentrer le canvas au coordonnées x, y	* On repositionne également le rectangle du zoomCanvas si la fen?tre de zoom est ouverte*/	public void recentre(int x, int y) {		setX(getSize().width/2 - x);		setY(getSize().height/2 - y);		if(zoomCanvas != null) zoomCanvas.setRect(new Rectangle(-getX(), -getY(), getSize().width, getSize().height));		repaint();		//System.out.println("recentre, x="+x+", y="+y);	}/**	* Permet de recentrer le canvas au coordonnées du noeud*/	public void recentre(Noeud unNoeud) {		recentre(unNoeud.x(), unNoeud.y());	}/**	* Déplacement du canvas*/	public void deplacer(int x, int y) {		int decX = (x - pos.x);		int decY = (y - pos.y);		setX(decX);		setY(decY);		pos.x=x;		pos.y=y;                if(zoomCanvas != null) zoomCanvas.setRect(new Rectangle(-getX(), -getY(), getSize().width, getSize().height));		repaint();	}/**	* permet de repositionner le canvas au coordonnées x y*/	public void rePositionne(int x, int y) {		//System.out.println("rePositionne en x="+x+", y="+y);		setX(x);		setY(y);		pos.x=x;		pos.y=y;		//if(zoomCanvas != null) zoomCanvas.setRect(new Rectangle(-getX(), -getY(), getSize().width, getSize().height));		repaint();	}/**************************** Le formattage a appliquer***************************//**	* On applique la méthode de formattage*/	public synchronized void formatter() {		if(formatter == null) setFormatter(FORMATTER_GD4);		if(noeudRacine() != null) formatter.formatter(noeudRacine());		if(zoomCanvas != null) {			zoomCanvas.clearRect();			zoomCanvas.refresh1();		}		repaint();	}/**	* On applique la méthode de formattage en repositionnant la racine à son ancienne position*/	public synchronized void formatter2() {	  if(painted) {	  	painted = false;		if(noeudRacine() != null) {			int xRac;			int yRac;			int index = rechNoeud(getSize().width/2, getSize().height/2); // L'index du noeud qui se trouve au centre du canvas			if(index != - 1) {				xRac = noeuds(index).x();				yRac = noeuds(index).y();			}			else {				xRac = noeudRacine().x();				yRac  = noeudRacine().y();			}			formatter.formatter(noeudRacine());			if(index != - 1) {				setX(xRac - noeuds(index).x());				setY(yRac - noeuds(index).y());			}			else {				setX(xRac - noeudRacine().x());				setY(yRac - noeudRacine().y());			}		}		repaint();                /*if(zoomCanvas != null) {                  zoomCanvas.clearRect();                  zoomCanvas.refresh1();		}*/	  }	}/**	* formatter en laissant inchangé la position du noeud passé en param?tre*/	public synchronized void formatter3(Noeud noeudSelect) {		int xOld = noeudSelect.x();		int yOld = noeudSelect.y();		//ZoomViewer zv = zoomCanvas;		//zoomCanvas = null;		formatter();		//System.out.println("formatter3 "+noeudSelect);		rePositionne(xOld-noeudSelect.x(), yOld-noeudSelect.y());		//zoomCanvas = zv;		if(zoomCanvas != null) {			zoomCanvas.clearGraphics();		  	zoomCanvas.refresh1();		}	}/**	* Choix de la méthode de formattage*/	public void setFormatter(int i) {		posLienRelations(0);		switch(i) {			case FORMATTER_GD: formatter = new FormatterGD(noeuds, getBounds()); break;			case FORMATTER_GD2: formatter = new FormatterGD2(noeuds, getBounds()); break;			case FORMATTER_GD3: formatter = new FormatterGD3(noeuds, getBounds()); break;			case FORMATTER_GD4: formatter = new FormatterGD4(noeuds); break;			case FORMATTER_GD5: formatter = new FormatterGD5(noeuds, getBounds()); break;			case FORMATTER_HB: formatter = new FormatterHB(noeuds);  posLienRelations(1); break;		}		formatter();	}/**	* Pour rafraichir l'affichage d'un noeud et ses attributs*/	public void refreshNoeud(Noeud o) {		setRect(((Noeud) o).rectRels());		calculDimension((Noeud) o);		addRect(((Noeud) o).rectRels());		repaint();	}/**	* Implémente Observer*/	public void update(Observable o, Object args) {		//System.out.println("update de GraphViewer "+this+" objet : "+o);		if(o instanceof Noeud) {			/*if(rechNoeud(o) == -1) {				Noeud unNoeud = creerNoeud(((Noeud) o).getLabel()); // Il ni a création que lorsque le noeud n'existe pas, sinon, le noeud existant est retourné			}*/			//formatter3((Noeud) o);			refreshNoeud((Noeud) o);			//formatter = null;			//formatter();		}	}} // Fin definition classe ArbreCanvas