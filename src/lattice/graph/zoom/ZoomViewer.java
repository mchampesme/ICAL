/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.zoom;/** * IKBS v2.2 - Canvas qui affiche une image réduite d'un arbre * David Grosser - 15 Janvier 1997 */import java.awt.Color;import java.awt.Cursor;import java.awt.Dimension;import java.awt.Graphics;import java.awt.Image;import java.awt.Rectangle;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.MouseMotionListener;import javax.swing.JPanel;public class ZoomViewer extends JPanel implements Runnable, MouseMotionListener, MouseListener {  //ZoomEditor ZoomEditor;  protected ZoomEditorInterface editor;  protected ZoomInterface canvas;	// Le canvas qui est zoomé  protected Image offscreen;		// L'image réduite de l'arbre  protected Image iGrand;     		// L'image taille réelle d'une partie de l'arbre  protected Image iRed;				// L'image taille réduite d'une partie de l'arbre  protected Graphics offgraphics;	// Le contexte graphique de l'image réduite et de this  protected Rectangle rect;     	// La zone actuellement affichée par GraphViewer (le rectangle)  protected Rectangle rTotale;			// La taille totale de l'arbre (rectangle englobant)  protected Rectangle rRefresh;		// Le rectangle a rafraichir  protected float factor;			// La facteur de zoom  protected boolean drag = false;	// Si on est en mode drag  protected boolean qualite = false;// Qualité de l'image réduite  protected Thread monThread;		// Le Thread qui se charge de gérer le calcul de l'image  protected boolean active = false;  protected boolean zoomPainted = false;  //protected boolean isFactorWidth = false; // true si le facteur de réduction maximal est la largeur  int debordX = 0; // Pour centrer la vue réduite  int debordY = 0;  int bordX = 5; // La bordure spérieur  int bordY = 5;  int decX = 0; // Décalage dynamique, utilisé par le zoom rapide (quality = false)  int decY = 0;  boolean deplacement = false;  int decalX = 0;  int decalY = 0;// Constructeurs  public ZoomViewer(ZoomInterface ic) {    super();    this.canvas = ic;    ic.setZoomViewer(this);    init();  }  public ZoomViewer(ZoomInterface ic, ZoomEditorInterface editor) {    super();    this.editor = editor;    this.canvas = ic;    ic.setZoomViewer(this);    init();  }  /**   * Initialisation   */  protected void init() {    setOpaque(true);    setBackground(canvas.getBackground());    addMouseListener(this); // Le gestionnaire d'évenements clic souris    addMouseMotionListener(this);  }  public boolean getQualite() {    return qualite;  }  public void clearRect() {    this.rect = null;  }  public boolean qualite() {    return qualite;  }  public void setQualite(boolean b) {    this.qualite = b;  }  public float getFactor() {    return factor;  }  public void setFactor(float f) {    factor = f;  }  public void run() {    if(qualite) refreshZoom();  }  /**   * Calcul de l'arbre réduit sans recalcul du facteur de réduction   */  public void refresh() {    if(rTotale != null) {      if((monThread != null)&&(monThread.isAlive())) {        monThread.stop();      }      creerNewThread();    }  }  protected void creerNewThread() {    monThread = new Thread(this);    monThread.setPriority(monThread.getPriority()-1);    monThread.start();  }  /**   * Recalcul de l'arbre avec calcul du facteur de zoom   */  public void refresh1() {    //synchronized(canvas) {      rTotale = canvas.dimension();      if(rTotale != null) {        if((rTotale.width == 0)||(rTotale.height == 0)) {        }        else {          factor = calculFactor(rTotale);          //debordX = 0;          //debordY = 0;          //if(! isFactorWidth) {          debordX = Math.round((getSize().width * factor - (float) rTotale.width)/2);          rTotale.x -= debordX;          rTotale.width += 2 * debordX;          //}          //else {          debordY = Math.round((getSize().height * factor - (float) rTotale.height)/2);          rTotale.y -= debordY;          rTotale.height += 2 * debordY;          //}          if(editor != null) editor.updateZoomFactor(factor);          rect = null;          //System.out.println(canvas.getX()+" "+canvas.getY());          setRect(new Rectangle(debordX-decalX, debordY-decalY, canvas.getSize().width, canvas.getSize().height));          decX = 0; decY = 0;          //if(rect == null) {          //setRect(new Rectangle(-canvas.getX(), -canvas.getY(), canvas.getSize().width, canvas.getSize().height));          //}          refresh();          //if(rect == null)        //}      }    }  }  protected void refreshZoom(Graphics g) {    initOffScreen(getSize().width, getSize().height);    offgraphics.setColor(canvas.getBackground());    offgraphics.fillRect(0, 0, getSize().width, getSize().height);    canvas.paintOffscreen(offgraphics, rTotale.x+decX, rTotale.y+decY, factor);//    g.setColor(canvas.getBackground());//    g.fillRect(0, 0, getSize().width, getSize().height);//    canvas.paintOffscreen(g, rTotale.x+decX, rTotale.y+decY, factor);  }  // Affichage du zoom apr?s calcul du facteur  protected void refreshZoom() {    int nbW = (rTotale.width/200)+1;// Le nombre d'itérations en largeur    int nbH = (rTotale.height/200)+1;// Le nombre d'itérations en hauteur    Dimension d = new Dimension( (int) (((double) rTotale.width)/((double) nbW)), (int) (((double) rTotale.height)/((double) nbH))); // La dimension de l'image réduite    initOffScreen(getSize().width, getSize().height);    iGrand = createImage(d.width, d.height); //Un morceau de l'image à réduire, taille réelle    Graphics g = iGrand.getGraphics();    Rectangle r2 = new Rectangle(0, 0, d.width, d.height);    int largeur = (int) (((float) d.width)/factor);    int hauteur = (int) (((float) d.height)/factor);    for (int i=0; i<nbH; i++) {      for(int j=0; j<=nbW; j++) {        setZoomPainted(false);        r2.x = rTotale.x + (d.width*j);        r2.y = rTotale.y + (d.height*i);        //rRefresh = new Rectangle(j*largeur, i*hauteur, largeur, hauteur);        g.setColor(canvas.getBackground());        g.fillRect(0, 0, d.width, d.height);        //synchronized(canvas) {        canvas.paintOffscreen(g, r2);        //}        //if(zoomPainted) {        if(qualite)          iRed = iGrand.getScaledInstance(largeur, hauteur, Image.SCALE_SMOOTH);        else iRed = iGrand.getScaledInstance(largeur, hauteur, Image.SCALE_DEFAULT);        //rRefresh = new Rectangle(j*largeur, i*hauteur, largeur, hauteur);        offgraphics.drawImage(iRed, j*largeur, i*hauteur, this);        //}        //  setZoomPainted(false);      }    }  }  protected void initOffScreen(int w, int h) {    //if((w != getSize().width)||(h != getSize().height)) {    if((offscreen != null)&&(offscreen.getWidth(this) == w)&&(offscreen.getHeight(this) == h)) {}    else {      if(offscreen != null) this.offscreen.flush();      this.offscreen = createImage(w, h);      this.offgraphics = offscreen.getGraphics();      Graphics g = getGraphics();      g.clearRect(0, 0, getSize().width, getSize().height);      /*if(this.rect != null) {        Rectangle rReduit;        rReduit = calculRectReduit(rect);        g.drawRect(rReduit.x, rReduit.y, rReduit.width, rReduit.height);      }*/    }  }  protected float calculFactor(Rectangle r) {    float factorW = ((float) r.width) / ((float) (this.getSize().width-bordX));    float factorH = ((float) r.height) / ((float) (this.getSize().height-bordY));    float factor = factorH;    //isFactorWidth = false;    if (factorW>factorH) {      factor = factorW;      //isFactorWidth = true;    }    return factor;  }  public void setBounds(int x, int y, int w, int h) {    super.setBounds(x, y, w, h);    refresh1();  }  public void setRect(Rectangle rect) {    if(this.rect != null) {      //rRefresh = calculRectReduit(this.rect);      this.rect.x += rect.x;      this.rect.y += rect.y;      decX -= rect.x;      decY -= rect.y;      this.rect.width = rect.width;      this.rect.height = rect.height;      deplacement = true;      //rRefresh.add(calculRectReduit(this.rect));    }    else {      if(rTotale!= null) {        this.rect = new Rectangle(-rTotale.x-decalX, -rTotale.y-decalY, rect.width, rect.height);        //rRefresh = new Rectangle(this.rect);      }    }    repaint();  }  protected Rectangle calculRectReduit(Rectangle r) {    return new Rectangle(Math.round(((float) r.x)/factor),                         Math.round (((float) r.y)/factor),                         Math.round(((float) r.width)/factor),                         Math.round(((float) r.height)/factor));  }  protected boolean dansRect(int x, int y) {    Rectangle r = new Rectangle((int) (((float)rect.x)/factor), (int) (((float)rect.y)/factor), (int)(((float)rect.width)/factor), (int)(((float) rect.height)/factor));    return r.contains(x, y);  }  public void update(Graphics g) {    paint(g);  }  public void setZoomPainted(boolean b) {    zoomPainted = b;  }  public void dispose() {    if((monThread != null)&&(monThread.isAlive())) {      monThread.stop();    }    monThread = null;    if(offscreen != null) offscreen.flush();    if(iGrand != null) iGrand.flush();  }  public void clearGraphics() {    //rRefresh = null;    offscreen = null;    if((monThread != null)&&(monThread.isAlive())) {      monThread.stop();    }    repaint();  }// implémente mouseMotionListener  public void mouseDragged(MouseEvent e) {    if(drag) {      int posX = (int) (((float) e.getX())*factor);      int posY = (int) (((float) e.getY())*factor);      canvas.deplacer(-posX, -posY);    }  }  public void mouseMoved(MouseEvent e) {  }// implémente MouseListener  public void mouseEntered(MouseEvent e) {  }  public void mouseExited(MouseEvent e) {  }  public void mousePressed(MouseEvent e) {    int posX = (int) (((float) (e.getX()))*factor);    int posY = (int) (((float) (e.getY()))*factor);    if(dansRect(e.getX(), e.getY())) {      drag = true;      setCursor(new Cursor(Cursor.MOVE_CURSOR));      canvas.setPosX(- posX);      canvas.setPosY(- posY);      canvas.dragMode();    }    else {      canvas.recentre(posX-rect.x, posY-rect.y);    }  }  public void mouseReleased(MouseEvent e) {    drag = false;    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));    canvas.mouseUp(e.getX(), e.getY());  }  public void mouseClicked(MouseEvent e) {  }  public void paint(Graphics g) {    //if(rRefresh != null) g.clipRect(rRefresh.x-5, rRefresh.y-5, rRefresh.width+6, rRefresh.height+6);    if(! qualite) {      if(! deplacement) {refreshZoom(g);}      else deplacement = false;    }    try {      g.clearRect(0, 0, getSize().width, getSize().height);      if(offscreen != null) {        g.drawImage(offscreen, 0, 0, this);      }      } catch (Exception e) {System.out.println("Not enough memory!");}      //   } /*   else {      if(! deplacement) {refreshZoom(g);}      else deplacement = false;    }*/      if(rect != null) {        //System.out.println("rect n'est pas null");        //g.drawRect((int) (((float)rect.x)/factor),(int) (((float)rect.y)/factor), (int)(((float)rect.width)/factor), (int)(((float) rect.height)/factor));        Rectangle rect2 = rect;        rect2.x = rect.x;//+decalX;        rect2.y = rect.y;//+decalY;        rect2.width = rect.width;        rect2.height = rect.height;        Rectangle rReduit = calculRectReduit(rect2);        g.setColor(canvas.getBackground());        //g.setXORMode(new Color(210, 210, 210));        //g.fillRect(0, 0, getSize().width, getSize().height);        //g.fillRect(rReduit.x, rReduit.y, rReduit.width, rReduit.height);        g.setColor(Color.red);        g.drawRect(rReduit.x, rReduit.y, rReduit.width, rReduit.height);        //g.setColor(Color.lightGray);        //g.drawRect(rReduit.x+1, rReduit.y+1, rReduit.width-2, rReduit.height-2);      }      //else System.out.println("rect est null");      //rRefresh = null;  }// fin paint  public Dimension getPreferredSize() {    return new Dimension(150, 140);  }  public void setDecalX(int dx) {    decalX = dx;  }  public void setDecalY(int dy) {    decalY = dy;  }}