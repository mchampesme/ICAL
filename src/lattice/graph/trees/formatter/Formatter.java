/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.trees.formatter;// import javaimport java.awt.Point;import java.util.Vector;import lattice.graph.trees.Noeud;/**	* IKBS - Classe abstraite de formattage d'arbres ou de graphes	* @author David Grosser	* @date 1 Février 2000*/public abstract class Formatter extends Object {	protected Vector noeuds; // référence sur la liste des noeuds a formatter	protected int cl = 6; // Contrainte d'espacement en largeur	protected int ch = 2; // Contrainte d'espacement en hauteur	public int zoom; // La taille du zoom	public Formatter(Vector noeuds) {		super();		this.noeuds = noeuds;	}	public abstract void formatter(Noeud unNoeud);	public void setCl(int cl) {		this.cl = cl;	}	public int cl() {		return  cl + (int) (zoom / 5);	}	public void setCh(int ch) {		this.ch = ch;	}	public int ch() {		return ch + (int) (zoom / 5);	}	public int getZoom() {		return zoom;	}	public void setZoom(int zoom) {		this.zoom = zoom;	}/**	* Acc?s au i?me noeud*/	public Noeud noeuds(int i) {		return (Noeud) noeuds.elementAt(i);	}/**	* Gestion du premier marqueur (pour éviter les cycles lors d'un parcours récursif)*/	protected void marquer() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque(true);	}/**	* Demarquer tous les noeuds*/	protected void demarquer() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque(false);	}// Gestion du deuxi?me marqueur	(pour éviter les cycles lors d'un parcours récursif)	protected void marquer2() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque2(true);	}	protected void demarquer2() {		for(int i=0; i<noeuds.size(); i++) noeuds(i).setMarque2(false);	}// Positionnement vertical ou horizontal des relations des noeuds	/*public void posLienRelations(int pos) {		for(int i=0; i<noeuds.size(); i++)			noeuds(i).setPosLien(pos);	}*//*	* Retourne les fils d'un noeud situé à la profondeur p	* Appel de la fonction récursive*/	public Vector fil(Noeud unNoeud, int p) {		demarquer2();		return fils(unNoeud, p);	}/**	* retourne les fils d'un noeud pour un niveau donne (recursif)*/	protected Vector fils(Noeud unNoeud, int p) {		Vector fils = new Vector();		Vector f = unNoeud.fils();		if(p == 0) {			if(! unNoeud.getMarque2()){				fils.addElement(unNoeud) ;				unNoeud.getMarque2();			}			return fils;		} // fin if		else {			for(int i=0; i<f.size(); i++) {				Vector lesFils = fils((Noeud)f.elementAt(i), p-1);				for(int j=0; j<lesFils.size(); j++)						fils.addElement(lesFils.elementAt(j));			} // fin for		return fils;		} // fin else	} // fin methode fils/**	* retourne les peres d'un noeud	* Si plusieurs p?res -> graphe*/	public Vector peres(Noeud unNoeud) {		Vector peres = new Vector() ;		for(int i=0; i < unNoeud.nbRelationArrive(); i++) //les relations au depart du noeud			peres.addElement((unNoeud.relationArrive(i)).origine()) ;		return peres;	}// fin pere/**	* Retourne les noeuds feuilles d'un noeud*/	public Vector feuilles(Noeud unNoeud) {		demarquer2();		return feuillesRec(unNoeud);	}/**	* retourne les feuilles du sous arbre de racine unNoeud (recursif)*/	protected Vector feuillesRec(Noeud unNoeud) {		Vector feuilles = new Vector();		Vector f = unNoeud.fils();		if((f.size() == 0)||(! (((Noeud) f.firstElement()).visible()))){			if(! unNoeud.getMarque2()){				feuilles.addElement(unNoeud) ;				unNoeud.setMarque2(true);			}			return feuilles;		} // fin if		else {			for(int i=0; i<f.size(); i++) {				Vector lesFeuilles = feuilles((Noeud)f.elementAt(i));				for(int j=0; j<lesFeuilles.size(); j++)						feuilles.addElement(lesFeuilles.elementAt(j));			} // fin for		return feuilles;		} // fin else	} // fin methode feuilles/**	* Retourne la profondeur d'un noeud dans l'arbre*/	public int prof(Noeud unNoeud) {		demarquer2() ;		return profondeur(unNoeud);	}/**	* calculer la profondeur du sous-arbre de racine unNoeud (recursif)*/	protected int profondeur(Noeud unNoeud) {		unNoeud.setMarque2(true) ;		int p = 0;		int k = 0;		Vector f = unNoeud.fils();		if(f.size() == 0) return 0;		else {			for (int i = 0; i < f.size(); i++) {				if (! ((Noeud)f.elementAt(i)).getMarque2()) { 					k = profondeur((Noeud)f.elementAt(i)) ;					if (k > p) p = k;				}			} // fin for			return p + 1;		} // fin else	} // fin profondeur/**	* Retourne le plus grand nombre de fils*/	public int plusGdNbFil(Noeud unNoeud) {		demarquer2();		return plusGdNbFils(unNoeud);	}/**	* calculer la dimension (plusGdNbFils) du sous-arbre de racine unNoeud (recursif)*/	protected int plusGdNbFils(Noeud unNoeud) {		unNoeud.setMarque2(true) ;		Vector f = unNoeud.fils() ;		int p = f.size() ;		for (int i = 0; i< f.size(); i++) {			if ( ! ((Noeud)f.elementAt(i)).getMarque2()) {				int k = plusGdNbFils((Noeud)f.elementAt(i)) ;				if (k > p) p = k;			}		}// fin for		return p;	}// fin plusGdNbFils/**	* Positionne recursivement le sous arbre de racine unNoeud*/	protected void positionne(Noeud unNoeud) {		unNoeud.setPos(new Point(unNoeud.x(), unNoeud.y()));//marquage1		//unNoeud.start();		Vector fils = unNoeud.fils();		for(int i=0; i<fils.size(); i++) { 			positionne((Noeud) fils.elementAt(i)) ; 		}	}/**	* Positionne récursivement en Y de la racine vers les feuilles (formattage vertical)	* c est le décalage courant en y*/	protected void positionneY(Noeud unNoeud, int c) {		unNoeud.setPosSup(new Point(unNoeud.x(), c)) ;//marquage1		unNoeud.setMarque2(true) ;		Vector fils = unNoeud.fils() ;		int hauteur = unNoeud.maxHauteur() ;		for(int i=0; i<fils.size(); i++) {			Noeud unFils = (Noeud) fils.elementAt(i);			if(! unFils.getMarque2()) {				positionneY(unFils, c + unNoeud.rect().height + ch() + hauteur) ;			}		}	}/**	* Positionne récursivement en X de la racine vers les feuilles (formattage horizontal)	* c représente la position courante en x*/	protected void positionneX(Noeud unNoeud, int c) {		unNoeud.setPosSup(new Point(c, unNoeud.y())) ; // On ne modifie que la coordonnées X//marquage1		unNoeud.setMarque2(true) ;		Vector fils = unNoeud.fils() ;		//int maxL = unNoeud.maxLargeur() ;		for(int i=0; i<fils.size(); i++) {			Noeud unFils = (Noeud) fils.elementAt(i);			if(! unFils.getMarque2()) {// pour éviter les cycles				int largeur = unNoeud.largeur(unFils);				//positionneX(unFils, c + unNoeud.rect().width + cl() + (int) ((double) maxL * 1.5)) ;				positionneX(unFils, c + unNoeud.rect().width + cl() + largeur) ;			}		}	}/**	* Calcul la hauteur a allouer pour cette feuille*//*	protected int calculH(Noeud unNoeud) {		Vector peres = peres(unNoeud);		if(peres.size()>0) {			Noeud papa = ((Noeud) peres.firstElement());			if(papa.nbFils() == 1) {				int h1 = papa.rect().height;				int h2 = unNoeud.rect().height;				return Math.max(h1, h2) + ch() ;			}		}		return unNoeud.rect().height + ch();	}*/	protected int calculH(Noeud unNoeud) {/*		Vector peres = peres(unNoeud);		if(peres.size()>0) {			Noeud papa = ((Noeud) peres.firstElement());			if(papa.nbFils() == 1) {				int h1 = papa.rect().height;				int h2 = unNoeud.rect().height;				return Math.max(h1, h2) + ch() ;			}		}*/		return unNoeud.rect().height + ch();	}/**	* retourne false si un des fils n'est pas marqué*/	protected boolean tousFilsMarque(Noeud unNoeud) {		Vector fils = unNoeud.fils() ;		boolean marq = true ;		for(int i=0; i<fils.size(); i++)			if(! ((Noeud) fils.elementAt(i)).getMarque()) marq = false ;		return marq ;	}/**	* retourne la somme des coordonnees Y des fils (formattage horizontal)*/	public int sommeYFils(Noeud unNoeud) {		Vector fils = unNoeud.fils() ;		int Y = 0;		for(int i=0; i<fils.size(); i++)			//Y = Y + ((Noeud) fils.elementAt(i)).supGaucheY() ;			Y = Y + ((Noeud) fils.elementAt(i)).y() ;//marquage1		return Y ;	}/**	* retourne la somme des coordonnees X des fils (formattage vertical)*/	public int sommeXFils(Noeud unNoeud) {		Vector fils = unNoeud.fils() ;		int X = 0;		Noeud unFils;		for(int i=0; i<fils.size(); i++) {			unFils = (Noeud) fils.elementAt(i);			X = X + unFils.x()+unFils.rect().width/2 ;//marquage1		}		return X ;	}/**	* Positionne récursivement en Y des feuilles vers la racine (formattage horizontal)*/	protected int positionneYPeres(Noeud unNoeud) {		unNoeud.setPosSup(new Point(unNoeud.x(), (int) (sommeYFils(unNoeud)/unNoeud.nbFils())-unNoeud.height()/2));//marquage1		unNoeud.setMarque(true) ;		Vector peres = peres(unNoeud) ;		for(int j=0; j<peres.size(); j++) {			Noeud papa = (Noeud) peres.elementAt(j);			if(tousFilsMarque(papa)) return positionneYPeres((Noeud) peres.elementAt(j));			else return calcMaxH(unNoeud);		}		return 0;	}/**	* calcul de la hauteur maximale*/	public int calcMaxH(Noeud unNoeud) {		int hMaxThis = unNoeud.supGaucheY() + calculH(unNoeud);		if(unNoeud.nbFils() == 0) return hMaxThis;		Noeud dernierFils = unNoeud.fils(unNoeud.fils().size()-1);		int hMaxFils = calcMaxH(dernierFils);		if(hMaxThis > hMaxFils) {			return hMaxThis;		}		else return hMaxFils;	}/**	* Positionne récursivement en X des feuilles vers la racine (formattage vertical)*/	protected void positionneXPeres(Noeud unNoeud) {		if(tousFilsMarque(unNoeud)) {			unNoeud.setPos(new Point( (int) (sommeXFils(unNoeud)/unNoeud.nbFils())-unNoeud.rect().width/2, unNoeud.y())) ;//marquage1			unNoeud.setMarque(true) ;			Vector peres = peres(unNoeud) ;			for(int j=0; j<peres.size(); j++) 				positionneXPeres((Noeud) peres.elementAt(j)) ;		}	}}