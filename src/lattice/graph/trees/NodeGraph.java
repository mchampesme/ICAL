/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.trees;/** * IKBS - Définition des noeuds graphiques génériques * Un noeud poss?de une liste d'attributs et de relations partant et arrivant sur ce noeud * Etant la classe racine des composants graphiques d'IKBS * @author David Grosser * @date mars 1997 * @version Version 2.9 * Revu le 14/06/2000 */import java.awt.Color;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Point;import java.awt.Rectangle;import java.util.Observable;import java.util.Observer;import java.util.Vector;import lattice.graph.utils.Rectangle3D;public class NodeGraph extends Composant implements Noeud, Selectable {  public static Color defaultColor = new Color(10, 210, 240);  public static Color racineColor  = new Color(217, 92, 118);// Gestion de la fl?che d'ouverture, fermeture des fils  //public static int widthArrow = 12;// Longueur de la fl?che  public static double angleArrow = ((double) Math.PI)/((double) 8); // angle des fleches en degree  public boolean activeNode = false;// Variables de classes  static protected int num = 0;// Variables d'instances  protected boolean selected, clicked; // Pour la gestion des selection  protected boolean racine, marque, marque2;// si true, alors noeud selectionné  protected Vector relationDepart, relationArrive; // Liste des relations qui partent du noeud  protected AttributsList attributs; // Liste des attributs du noeud  protected boolean affAttributs;	// true si on doit afficher les attributs  protected boolean visible; // true : on affiche le noeud  //boolean affSousArbre;	// true : les fils sont affichés  protected boolean affMenu; // Affichage du bouton d'édition du noeud  //protected MenuList menu;  protected boolean bordered; // Affichage de l'encadrement  //protected boolean shadow = true;  protected Rectangle rect3 = null;  public int widthArrow = 12;// Longueur de la fl?che  public boolean rounded = false;  /**   * Constructeur de la classe noeud. Appel du constructeur de la classe Composant   * @see ikbs.graphics.Composant   */  public NodeGraph() {    super();    setLabel("objet n°" + String.valueOf(num));    setPos(0, 0);    init();  }  public NodeGraph(String nom) {    super(nom);    setLabel(nom);    setPos(0,0);    init();  }  public NodeGraph(String nom, Point position) {    super(nom);    setLabel(nom);    setPos(position);    init();  }  public NodeGraph(Point position) {    setLabel("objet n°" + String.valueOf(num));    setPos(position);    init();  }  /**   * Acc?s à la variable qui détermine si le noeud affiche ouu pas une fl?che pouur le masquage des fils   */  public boolean getActiveNode() {    return activeNode;  }  /**   * Le noeud est actif pour le masquage/démasquage de ses fils   */  public void setActiveNode(boolean b) {    this.activeNode = b;  }  /**   * Affectation de la couleur du noeud   */  public static void setDefaultColor(Color c) {    defaultColor = c;  }  public void setAttributs(AttributsList attributs) {this.attributs = attributs;}  /**   * Affectation de la couleur de la racine   */  public static void setRacineColor(Color c) {    racineColor = c;  }// Initialisation  protected void init() {    num++;    labelColor = Color.black;    bgColor = defaultColor;    selected = false;    racine = false;    marque = false;    marque2 = false;    relationDepart = new Vector();    relationArrive = new Vector();    attributs = new AttributsList(this);    affAttributs = false;    visible = true;    affMenu = false;    //menu = new MenuList(this);    bordered = true;  }  public void initColor() {    labelColor = Color.black;    bgColor = defaultColor;  }  public void addObserver(Observer o) {    super.addObserver(o);  }// Méthodes d'acc?s  public void setRacine(boolean b) {    racine = b ;    if(b) setBgColor(racineColor);    else setBgColor(defaultColor);  }  public boolean getRacine() {    return this.racine;  }  public boolean affMenu() {    return affMenu;  }  public void setAffMenu(boolean b) {    affMenu = b;  }  public void setBordered(boolean b) {    bordered = b;  }  public void setRounded(boolean b) {    rounded = b;  }  /**   * Implémente Observer   * Retransmet directement aux observateurs (l'environnement graphique)   * les param?tres de update   */  public void update(Observable o, Object args) {    setChanged();    notifyObservers(args);  }  public void bouge(int dx, int dy) {    //setPos(new Point(x() + dx, y() + dy));    x += (double) dx;    y += (double) dy;    //setPos(x() + dx + (width()/2), y() + dy + (height()/2));  }  public void setPosSup(Point p) {    setPos(p.x + width()/2, p.y + height()/2) ;  } /*public void setPosSup2(Point p) {  setPos2(p.x + width()/2, p.y + height()/2); }*/  public Vector relations() {    Vector rel = new Vector();    for(int i=0; i<nbRelationDepart(); i++) {      rel.addElement(relationDepart(i));    }    for(int j=0; j<nbRelationArrive(); j++) {      rel.addElement(relationArrive(j));    }    return rel;  }  public Vector relationDepart() {    return relationDepart;  }  public Vector relationArrive() {    return relationArrive;  }  public int maxLargeur() {    int largeur = 0;    for(int i=0; i<nbRelationDepart(); i++)      if (relationDepart(i).widthLabel() > largeur)        largeur = relationDepart(i).widthLabel();    return largeur;  }  public int largeur(Noeud n) {    Relation r = rechRelationDepart(n);    if(r != null) {      return r.widthLabel();    }    else return 0;  }  public int maxHauteur() {    int hauteur = 0;    for(int i=0; i<nbRelationDepart(); i++)      if (relationDepart(i).heightLabel() > hauteur)        hauteur = relationDepart(i).heightLabel();    return hauteur;  }  public Relation relationDepart (int i) {    return (Relation) relationDepart.elementAt(i);  }  public Relation relationArrive (int i) {    return (Relation) relationArrive.elementAt(i);  }  public void setRelationDepart(int i, Relation rel) {    relationDepart.setElementAt(rel, i);  }  public void setRelationArrive(int i, Relation rel) {    relationArrive.setElementAt(rel, i);  }  public void addRelationDepart(Relation uneRelation) {    relationDepart.addElement(uneRelation);  }  public void addRelationArrive(Relation uneRelation) {    relationArrive.addElement(uneRelation);  }  public int nbRelationDepart(){    return relationDepart.size();  }  public int nbRelationArrive(){    return relationArrive.size();  }  public int rechIndiceRelDepart(Noeud n) {    for(int i=0; i<nbRelationDepart();i++) {      if(relationDepart(i).extremite() == n) return i;    }    return -1;  }  public Relation rechRelationDepart(Noeud n) {    for(int i=0; i<nbRelationDepart();i++) {      if(relationDepart(i).extremite() == n) return relationDepart(i);    }    return null;  }  public Relation rechRelationDepart(String s) {    //System.out.println(s);    for(int i=0; i<nbRelationDepart();i++) {      if(relationDepart(i).extremite().getLabel().equals(s)) return relationDepart(i);    }    return null;  }  public int rechIndiceRelArrive(Noeud n) {    for(int i=0; i<nbRelationArrive();i++) {      if(relationArrive(i).origine() == n) return i;    }    return -1;  }  public Relation rechRelationArrive(Noeud n) {    for(int i=0; i<nbRelationArrive();i++) {      if(relationArrive(i).origine() == n) return relationArrive(i);    }    return null;  }  public void removeRelation(Relation uneRelation) {    removeRelationDepart(uneRelation);    removeRelationArrive(uneRelation);  }  public void removeAttribut(String s) {    attributs.remove(s);  }  /**   * On efface toutes les relations du noeud   */  public void removeRelations() {    for(int i=0; i<nbRelationArrive(); i++) {      Relation r = relationArrive(i);      r.origine().removeRelationDepart(r);    }    for(int j=0; j<nbRelationDepart(); j++) {      Relation r = relationDepart(j);      r.extremite().removeRelationArrive(r);    }  }  public void removeRelationDepart(Relation uneRelation) {    for(int i=0; i<nbRelationDepart();)      if(uneRelation==relationDepart(i))        relationDepart.removeElementAt(i);    else i++;  }  public void removeRelationDepart(Noeud unNoeud) {    for(int i=0; i<nbRelationDepart();)      if (relationDepart(i).extremite()==unNoeud)        removeRelationDepart(relationDepart(i));    else i++;  }  public void removeRelationArrive(Relation uneRelation) {    for(int i=0; i<nbRelationArrive();)      if(uneRelation==relationArrive(i))        relationArrive.removeElementAt(i);    else i++;  }  public void removeRelationArrive(Noeud unNoeud) {    for(int i=0; i<nbRelationArrive();)      if (relationArrive(i).origine()==unNoeud)        removeRelationArrive(relationArrive(i));    else i++;  }  public Vector peres() {    Vector fils = new Vector();    for(int i=0; i<nbRelationArrive(); i++){      fils.addElement(relationArrive(i).origine());    }    return fils;  }  public Vector fils() {    Vector fils = new Vector();    for(int i=0; i<nbRelationDepart(); i++){      fils.addElement(relationDepart(i).extremite());    }    return fils;  }  public Noeud fils(int i) {    return relationDepart(i).extremite();  }  public int nbFils() {    return nbRelationDepart();  }  public boolean isFilsVisible() {    for(int i=0; i<nbRelationDepart(); i++)      if( ! (relationDepart(i).extremite().visible())) return false;    return true;  }  public boolean racine() { return racine ; }  public void setMarque(boolean b) {marque = b ;}  public boolean getMarque() {return marque;}  public void setMarque2(boolean b) {marque2 = b ;}  public boolean getMarque2() {return marque2;}// Méthodes d'acc?s pour les attributs  public boolean affAttributs() {return affAttributs ;}  public boolean visible() {return visible ;}  public void setVisible(boolean v) {visible = v;} /*public boolean isFilsVisible() {  if (nbRelationDepart() != 0)   return (relationDepart(0).extremite()).visible();  else return true; }*/  //boolean affSousArbre() {return affSousArbre ;}  //public void setAffSousArbre(boolean v) {affSousArbre = v;}  public void setAffAttributs(boolean b) {affAttributs = b ;}  public AttributsList attributs() {return attributs;}  public Attribut attribut(String nomAtt) {return attributs.elementName(nomAtt);}  public Attribut attribut(int i) {return attributs.attribut(i);}  public Attribut rechAttribut(String label) {    for(int i=0; i<nbAtt(); i++) {      if(attribut(i).getLabel().equals(label)) return attribut(i);    }    return null;  }// retourne l'attribut suivant de celui dont le nom est passé en param?tre  public Attribut rechAttSuivant(String label) {    for(int i=0; i<nbAtt(); i++) {      if(attribut(i).getLabel().equals(label)) {        if(i<(nbAtt()-1)) return attribut(i+1);        else return attribut(0);      }    }    return null;  }// retourne l'attribut précédent de celui dont le nom est passé en param?tre  public Attribut rechAttPrecedent(String label) {    for(int i=0; i<nbAtt(); i++) {      if(attribut(i).getLabel().equals(label)) {        if(i>0) return attribut(i-1);        else return attribut(nbAtt()-1);      }    }    return null;  }  /**   *  Pour calculer la dimension des objets de l'arbre   */  public void calculDimensionObj(FontMetrics fm) {    setWidthLabel(fm.stringWidth(getLabel()));    setHeightLabel(fm.getHeight());    setWidth(widthLabel()+3*fm.charWidth(' '));    setHeight(2*fm.getMaxDescent()+fm.getMaxAscent()+2);    if(activeNode) calculDimensionMButton(fm);  }  /**   * Calcul de la dimension des MButton   */  public void calculDimensionMButton(FontMetrics fm) {    if(nbFils()>0) {      widthArrow = fm.getHeight();      setWidth(width() + widthArrow);      rect3 = new Rectangle(infDroitX()-widthArrow, supGaucheY(), widthArrow, height());    }  }  /**   * Pour calculer la dimension de this, de ses attributs et de ses relations   */  public void calculDimension(FontMetrics fmObj, FontMetrics fmAtt,  FontMetrics fmRel) {    calculDimensionObj(fmObj);    attributs.calculDimension(fmAtt);    calculDimensionRel(fmRel);  }  /**   * Pour calculer la dimension des attributs   */  public void calculDimensionAtt(FontMetrics fm) {    attributs.calculDimension(fm);  }  /**   * Pour calculer la dimension des relations   */  public void calculDimensionRel(FontMetrics fm) {    Vector rel = relations();    for (int i=0; i<rel.size(); i++) {      ((Relation) rel.elementAt(i)).calculDimension(fm);    }  }  public Rectangle rect() {    Rectangle r = rect2();    if (affAttributs()) {      r.add(attributs.rect());    }    return r;  }  // Le rectangle sans la liste des fils  public Rectangle rect2() {    return new Rectangle(supGaucheX(), supGaucheY(), width()+2, height()+2) ;  }  public Rectangle rect3() {    return rect3;  }  public Rectangle rectRels() {    Rectangle r = rect();    for(int i=0; i < nbRelationDepart(); i++) //les relations au depart du noeud      r.add(((Relation) relationDepart(i)).rect());    for(int i=0; i < nbRelationArrive(); i++) //les relations qui arrivent sur le noeud      r.add(((Relation) relationArrive(i)).rect());    return r ;  }  /***********************   * Interface selectable *   ***********************/  public void setSelected(boolean b) {    selected = b;  }  public boolean getSelected() {    return selected;  }  public void setClicked(boolean b) {    clicked = b;  }  public boolean getClicked() {    return clicked;  }// fin selectable  public int supGaucheX() {    return x() - width() / 2;  }  public int supGaucheY() {    return y() - height() / 2;  }  public Point supGauche() {    return (new Point(supGaucheX(), supGaucheY()));  }  public int infDroitX() {    return 	x() + width() / 2;  }  public int infDroitY() {    return 	y() + height() / 2;  }  public Point infDroit() {    return (new Point(infDroitX(), infDroitY()));  }  /******************************************   ** Les méthodes pour gerer les attributs **   *******************************************/  // Ajouter un attribut  public void addAttribut(Attribut unAttribut) {    //System.out.println("Avant"+attributs.nbElement());    attributs.add(unAttribut) ;    //System.out.println(attributs.nbElement());  }  public Attribut createAttribute() {    //System.out.println("createAttribute de Node");    Attribut a = new Attribut(this);    addAttribut(a);    return a;  }  // Mettre a jours un attribut  public void updateAttribut(int index, Attribut newAttribut) {    //int index = find(oldAttribut);    if(index !=-1) attributs.setElementAt(newAttribut, index);  }  /**   * Retourne l'index de l'attribut de label label   */  public int find(Attribut att) {    return attributs.find(att.getLabel());  } /*public void removeAttribut(String nomAttribut) {  attributs.remove(nomAttribut); }*/  // Nombre d'attributs  public int nbAtt() {return attributs.nbElement();}  public void setBgColor(Color c) {    if(! racine()) {      super.setBgColor(c);    }    else super.setBgColor(racineColor);  }  // change la couleur du fond de la liste d'attributs  public void setBgColorAtt(Color c) {    attributs.setBgColor(c);  }  // change la couleur du texte de la liste d'attributs  public void setLabelColorAtt(Color c) {    attributs.setLabelColor(c);  }  public Attribut dansAttributs(int x, int y) {    return attributs.dansAttributs(x, y);  }  public Attribut selectAttributs(int x, int y) {    return attributs.dansAttributs(x, y);  }  /******************************************   ** Les méthodes pour s'afficher          **   ******************************************/  public void changeFormeRelation(int forme) {    for(int i=0; i<nbRelationDepart(); i++) {      relationDepart(i).setForme(forme);    }    for(int j=0; j<nbRelationArrive(); j++) {      relationArrive(j).setForme(forme);    }  }  public void showLabelRelations(boolean b) {    for(int i=0; i<nbRelationDepart(); i++) {      if(b) relationDepart(i).showLabel();      else  relationDepart(i).hideLabel();    }    for(int j=0; j<nbRelationArrive(); j++) {      if(b) relationArrive(j).showLabel();      else relationArrive(j).hideLabel();    }  }  public void setPosLien(int pos) {    for(int j=0; j<nbRelationArrive(); j++) {      relationArrive(j).setPosLien(pos);    }  }  public void setShowArrow(boolean b) {  /*for(int i=0; i<nbRelationDepart(); i++) {   relationDepart(i).setShowArrow(b);  }*/    for(int j=0; j<nbRelationArrive(); j++) {      relationArrive(j).setShowArrow(b);    }  }  public void paintShadow(Graphics g, int xRel, int yRel) {    if(visible) {      //Color c = g.getColor();      //g.setColor(c.brighter());      g.fillRect(supGaucheX()+xRel+shadowSize.width-4, supGaucheY()+yRel+shadowSize.height-4, width()+4, height()+4);      //g.setColor(c);      //g.fillRect(supGaucheX()+xRel+shadowSize.width-3, supGaucheY()+yRel+shadowSize.height-3, width()+2, height()+2);      if(! bordered) {        g.setColor(Color.white);        g.fillRect(supGaucheX()+xRel+shadowSize.width-2, supGaucheY()+yRel+shadowSize.height-2, width(), height());      }    }  }  public void paintShadowRounded(Graphics g, int xRel, int yRel) {    if(visible) {      g.fillOval(supGaucheX()+xRel+shadowSize.width-4, supGaucheY()+yRel+shadowSize.height-5, width()+4, height()+4);      //g.fillOval(supGaucheX()+xRel+shadowSize.width-2, supGaucheY()+yRel+shadowSize.height-2, width(), height());    }  }  /**   * On dessine le noeud   */  public void paint(Graphics g, int xRel, int yRel) {    if(visible) {      FontMetrics fm = g.getFontMetrics();      if(racine()) {        g.setColor(cible_color);        if(! rounded) paintShadow(g, xRel, yRel);        else paintShadowRounded(g, xRel, yRel);        paintAttShadow(g, xRel, yRel);      }      if(getSelected()) {        g.setColor(shadow_color);        if(! rounded) paintShadow(g, xRel, yRel);        else paintShadowRounded(g, xRel, yRel);        paintAttShadow(g, xRel, yRel);      }      if(bordered) {        Rectangle3D r = new Rectangle3D(bgColor(), supGaucheX()+xRel, supGaucheY()+yRel, width(), height());        if(getClicked()) r.setDrawingMode(Rectangle3D.IN);        else r.setDrawingMode(Rectangle3D.OUT);        r.paint(g);      }      if(rounded) {        g.setColor(bgColor());        g.fillOval(supGaucheX()+xRel, supGaucheY()+yRel-1, width(), height());        g.setColor(bgColor().darker());        g.drawOval(supGaucheX()+xRel, supGaucheY()+yRel-1, width(), height());      }      g.setColor(labelColor);      paintLabel(g, fm, xRel, yRel);      if(activeNode) paintActive(g, xRel, yRel);    } // fin si visible  } // fin paint  public void paintAttShadow(Graphics g, int xRel, int yRel) {    if((affAttributs) && (nbAtt()>0)) attributs.paintShadow(g, xRel, yRel);  }  public void paintAtt(Graphics g, int xRel, int yRel) {    if((affAttributs) && (nbAtt()>0)) attributs.paint(g, xRel, yRel);  }  protected void paintLabel(Graphics g, FontMetrics fm, int xRel, int yRel) {    if(getClicked())      g.drawString(getLabel(), xRel+1+supGaucheX()+(3*fm.charWidth(' '))/2, yRel+infDroitY()-fm.getMaxDescent()-fm.getMaxDescent()/2);    else g.drawString(getLabel(), xRel+supGaucheX()+(3*fm.charWidth(' '))/2, yRel+infDroitY()-1-fm.getMaxDescent()-fm.getMaxDescent()/2);  }  /**   * Dessin des relations   */  public void paintRelations(Graphics g, int xRel, int yRel) {    for(int j = 0; j<nbRelationDepart(); j++) {      //if(formeRelation == 1) noeuds(i).relations(j).paint(g, showArrow);      //else      if((visible())&&(relationDepart(j).extremite().visible())) {        relationDepart(j).paint(g, xRel, yRel);      }    }  }  /**   * Dessin de la fl?che pour développer/masquer les noeuds   */  public void paintActive(Graphics g, int xRel, int yRel) {    if(nbFils()>0) {      if(isFilsVisible()) {        if(getClicked()) paintArrow(g, x()+xRel+1, y()+yRel+1, infDroitX()+1-widthArrow/4+xRel+1, y()+yRel+1);        else paintArrow(g, x()+xRel, y()+yRel, infDroitX()-widthArrow/4+xRel, y()+yRel);      }      else {        if(getClicked()) paintArrow(g, infDroitX()+1-widthArrow/2+xRel, infDroitY()-height()+1+yRel, infDroitX()-widthArrow/2+xRel+1, infDroitY()-widthArrow/4+yRel+1);        else paintArrow(g, infDroitX()-widthArrow/2+xRel, infDroitY()-height()+yRel, infDroitX()-widthArrow/2+xRel, infDroitY()-widthArrow/4+yRel);      }    }  }  /**   * Pour dessiner la fl?che   * (x1, y1) : coordonnées du point d'origine   * (x2, y2) : coordonnées du point destination   */  public void paintArrow(Graphics g,int x1, int y1, int x2, int y2) {    int l = widthArrow; // La largeur de la fl?che    double xd1 = (double) x1 - x2;    double yd1 = (double) y1 - y2;    double tempo = Math.sqrt(2.0)/2.0;    double d = Math.sqrt((xd1*xd1)+(yd1*yd1));    int x = (int) (x2 + (l * tempo * (xd1*Math.cos(angleArrow) - yd1*Math.sin(angleArrow)))/d);    int y = (int) (y2 + (l * tempo * (yd1*Math.cos(angleArrow) + xd1*Math.sin(angleArrow)))/d);    int x3 = (int) (x2 + (l * tempo * (xd1*Math.cos(angleArrow) + yd1*Math.sin(angleArrow)))/d);    int y3 = (int) (y2 + (l * tempo * (yd1*Math.cos(angleArrow) - xd1*Math.sin(angleArrow)))/d);    int arrowhead_x[] = { x2, x, x3, x2 };    int arrowhead_y[] = { y2, y, y3, y2 };    g.fillPolygon(arrowhead_x, arrowhead_y, 4);  }  /**   * Retourne une copie profonde de this (sans les relations)   */  public Object clone() {    NodeGraph newNode = new NodeGraph(getLabel(), pos());    newNode.setActiveNode(getActiveNode());    AttributsList newList = (AttributsList) attributs.clone(newNode);    newList.setNoeud(newNode);    newNode.attributs = newList; // Copy de la liste d'attributs    newNode.affAttributs = affAttributs;    return newNode;  }}// fin classe Noeud