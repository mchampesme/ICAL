/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.gui.graph.threeD;/* * LatticeViewer.java * Date :       18th Feb 1998 * Adapted by : Simon P.A.Gill * WWW :	http://www.le.ac.uk/engineering/spg3/lattice/ * * The following java code is an adaptation of the Molecule Viewer XYZApp.java * freely distributed by Sun Microsystems. The conditions stated below apply * to this code. S.P.A. Gill takes no responsibility for this code. * Requires class Matrix3D.java (also from Sun at * http://www.javasoft.com:80/applets/js-applets.html) * ***************************************************************************** * * @(#)XYZApp.java	1.3 96/12/06 * * Copyright (c) 1994-1996 Sun Microsystems, Inc. All Rights Reserved. * * Sun grants you ("Licensee") a non-exclusive, royalty free, license to use, * modify and redistribute this software in source and binary code form, * provided that i) this copyright notice and license appear on all copies of * the software; and ii) Licensee does not utilize the software in a manner * which is disparaging to Sun. * * This software is provided "AS IS," without a warranty of any kind. ALL * EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY * IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR * NON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN AND ITS LICENSORS SHALL NOT BE * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING * OR DISTRIBUTING THE SOFTWARE OR ITS DERIVATIVES. IN NO EVENT WILL SUN OR ITS * LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, * INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER * CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF * OR INABILITY TO USE SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE * POSSIBILITY OF SUCH DAMAGES. * * This software is not designed or intended for use in on-line control of * aircraft, air traffic, aircraft navigation or aircraft communications; or in * the design, construction, operation or maintenance of any nuclear * facility. Licensee represents and warrants that it will not use or * redistribute the Software for such purposes. *//* * Initially a set of classes to parse, represent and display Chemical compounds * in .xyz format (see http://chem.leeds.ac.uk/Project/MIME.html). Now adapted * to also display interatomic bonds, allow the user to define the atomic radii * and colour of the atoms and define other lines in the display (such as the * unit cell). This code will still display .xyz files but all the atoms will * look the same (the default atom size and colour) unless they are defined * in the .xyz file. A .xyz file in which the bond locations and atom colours and * sizes have been defined have been distinguished by the .lat extension * * FILE FORMAT : * * The file format is based around the standard .xyz file which defines the * position in space of the atoms in the lattice * (see http://cst-www.nrl.navy.mil/lattice/ for details and many examples). * Any comments must be removed. Each atom type must be defined. * The following line defines an atom by its name (C), its RGB colour (red=255, * green=0, blue=0) and relative size (default=1.0, minimum=0.0 maximum=2.0) * *	ATOM  C  255  0  0  1.0 * * The position and bonds of the atom are defined as follows : * *  	C  0.0  1.0  0.0  3  6  8 * * This places a carbon (C) atom at the co-ordinates (0.0,1.0,0.0) and says that * bonds exist between it and the 3rd, 6th and 8th atoms in the list of atoms. * An atom can have an unlimited number of bonds, the only restriction is that * the total is less than 300 (unless the array size of bonds[] is increased. * NOTE - any atom defined with a size of 0.0 (eg ATOM X 0 0 0 0.0) can be used * to define the location of a position in space without an atom being placed * there. Any bonds between such points are known as the BOX (as these have * been used here to define the unit cell of a lattice) and are only displayed * if parameter box has value=true (see below). * * APPLET OPTIONS : * * PARAM = model	VALUE = filename * PARAM = label	VALUE = true/false	- labels atoms with their *						  numerical position in the list. *						  Very useful when defining bond *						  positions (default = false) * PARAM = scale	VALUE = float		- size of lattice in applet (default=1.0) * PARAM = box		VALUE = true/false	- the box concept is defined above. *						  Only displayed if TRUE (default=false) * PARAM = bonds	VALUE = true/false	- display interatomic bonds if true (default=false). * PARAM = bgcolor	VALUE = RGB colour	- background colour (default=lightGrey) * PARAM = bondcolor	VALUE = RGB colour	- bond colour (default=black) * PARAM = boxcolor	VALUE = RGB colour 	- colour of box bonds (default=red) * * NOTE - it has been found that this applet runs significantly better under Sun's * appletviewer than on Netscape (especially when viewing complex structures) */import java.applet.Applet;import java.awt.Color;import java.awt.Dimension;import java.awt.Event;import java.awt.Graphics;import java.awt.Image;import java.io.InputStream;import java.net.URL;/** An applet to put a Chemical/Atomic Lattice model into a page */public class LatticeViewer extends Applet implements Runnable {    XYZLatticeModel md;    boolean painted = true;    float xfac;    int prevx, prevy;    float xtheta, ytheta;    float scalefudge = 1;    Matrix3D amat = new Matrix3D(), tmat = new Matrix3D();    String mdname = null;    String message = null;    boolean label = false;    boolean box = false;    boolean bonds = false;    Image backBuffer;    Graphics backGC;    Dimension backSize;    String param;    Color bgcolor, bondcolor, boxcolor;    private synchronized void newBackBuffer() {	backBuffer = createImage(getSize().width, getSize().height);	backGC = backBuffer.getGraphics();	backSize = getSize();    }    public void init() {	mdname = getParameter("model");	try {	    scalefudge = Float.valueOf(getParameter("scale")).floatValue();	} catch(Exception e) {	};	try {	    label = Boolean.valueOf(getParameter("label")).booleanValue();	} catch(Exception e) {	};	try {	    box = Boolean.valueOf(getParameter("box")).booleanValue();	} catch(Exception e) {	};	try {	    bonds = Boolean.valueOf(getParameter("bonds")).booleanValue();	} catch(Exception e) {	};	try {	    param = getParameter("bgcolor");	} catch(Exception e) {	};        try {	   Integer i = Integer.valueOf(param, 16);	   bgcolor = new Color(i.intValue());        } catch (NumberFormatException e) {	   bgcolor = Color.white;        }	try {	    param = getParameter("bondcolor");	} catch(Exception e) {	};        try {	   Integer i = Integer.valueOf(param, 16);	   bondcolor = new Color(i.intValue());        } catch (NumberFormatException e) {	   bondcolor = Color.black;        };	try {	    param = getParameter("boxcolor");	} catch(Exception e) {	};        try {	   Integer i = Integer.valueOf(param, 16);	   boxcolor = new Color(i.intValue());        } catch (NumberFormatException e) {	   boxcolor = Color.red;        };	amat.yrot(20);	amat.xrot(20);	if (mdname == null)	    mdname = "model.obj";	resize(getSize().width <= 20 ? 400 : getSize().width,	       getSize().height <= 20 ? 400 : getSize().height);	newBackBuffer();    }    public void run() {	InputStream is = null;	try {	    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);	    is = new URL(getDocumentBase(), mdname).openStream();	    XYZLatticeModel m = new XYZLatticeModel (is, label, box, bonds, bgcolor, bondcolor, boxcolor);	    //ScaleableAtom.setApplet(this);	    md = m;	    m.findBB();	    float xw = m.xmax - m.xmin;	    float yw = m.ymax - m.ymin;	    float zw = m.zmax - m.zmin;	    if (yw > xw)		xw = yw;	    if (zw > xw)		xw = zw;	    float f1 = getSize().width / xw;	    float f2 = getSize().height / xw;	    xfac = 0.7f * (f1 < f2 ? f1 : f2) * scalefudge;	} catch(Exception e) {	    e.printStackTrace();	    md = null;	    message = e.toString();	}	try {	    if (is != null)		is.close();	} catch(Exception e) {	}	repaint();    }    public void start() {	if (md == null && message == null)	    new Thread(this).start();    }    public void stop() {    }    public boolean mouseDown(Event e, int x, int y) {	prevx = x;	prevy = y;	return true;    }    public boolean mouseDrag(Event e, int x, int y) {	tmat.unit();	float xtheta = (prevy - y) * (360.0f / getSize().width);	float ytheta = (x - prevx) * (360.0f / getSize().height);	tmat.xrot(xtheta);	tmat.yrot(ytheta);	amat.mult(tmat);	if (painted) {	    painted = false;	    repaint();	}	prevx = x;	prevy = y;	return true;    }    public void update(Graphics g) {	if (backBuffer == null)	    g.clearRect(0, 0, getSize().width, getSize().height);	paint(g);    }    public void paint(Graphics g) {	if (md != null) {	    md.mat.unit();	    md.mat.translate(-(md.xmin + md.xmax) / 2,			     -(md.ymin + md.ymax) / 2,			     -(md.zmin + md.zmax) / 2);	    md.mat.mult(amat);	    // md.mat.scale(xfac, -xfac, 8 * xfac / size().width);	    md.mat.scale(xfac, -xfac, 16 * xfac / getSize().width);	    md.mat.translate(getSize().width / 2, getSize().height / 2, 8);	    md.transformed = false;	    if (backBuffer != null) {		if (!backSize.equals(getSize()))		    newBackBuffer();                //setBackground(bgcolor);		//backGC.setColor(bgcolor);		//backGC.fillRect(0,0,getSize().width,getSize().height);                setBackground(Color.white);                backGC.setColor(bgcolor);		backGC.fillRect(0,0,getSize().width,getSize().height);		md.paint(backGC);		g.drawImage(backBuffer, 0, 0, this);	    }	    else		md.paint(g);	    setPainted();	} else if (message != null) {	    g.drawString("Error in model:", 3, 20);	    g.drawString(message, 10, 40);	}    }    private synchronized void setPainted() {	painted = true;	notifyAll();    }    private synchronized void waitPainted()    {       while (!painted)       {          try          {             wait();          }          catch (InterruptedException e) {}       }       painted = false;    }}   // end class LatticeViewer