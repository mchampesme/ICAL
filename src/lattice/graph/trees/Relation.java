/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.trees;import java.awt.Color;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Point;import java.awt.Rectangle;/**	* IKBS - Editeur d'arbre de description	* Définition de la hierarchie des classes relation	* David Grosser - Mars 1997 - IREMIA, Université de la Réunion	* Version 1.0	* Revu le 7/04/97**/public class Relation extends Composant implements Selectable {	// Constantes	public static final int FORME_ESCALIER = 0;	public static final int FORME_DROITE = 1;	public static boolean decalage2dPoint = true;// Si décalage du 2d point	public static boolean doubleTrait = false;	// Variables de classes	protected static Color backgroundColor = Color.black;	protected static int numRel = 0;	protected static int widthArrow = 24;	protected static double angleArrow = ((double) Math.PI)/((double) 10); // angle des fleches en degree	// Variables d'instances	protected Noeud origine, extremite ;	protected int posLien; // posLien = 0 (par défaut) -> lien de l'extremité droite de l'origine jusqu'à l'extrémité gauche de l'extrémite	protected boolean showArrow, selected;	protected int forme;	public Color normal_color = Color.black;	// Constructeurs	public Relation() {		super();		numRel++;		setLabel("relation " + String.valueOf(numRel));	}	public Relation(Noeud noeud1, Noeud noeud2) {		super();		origine = noeud1;		extremite = noeud2;		numRel++;		setLabel("relation " + String.valueOf(numRel));		init();	}	public Relation(Noeud noeud1, Noeud noeud2, String nom) {		super();		origine = noeud1;		extremite = noeud2;		numRel++;		setLabel(nom);		init();	}	public Relation(Noeud noeud1, Noeud noeud2, String nom, FontMetrics fm) {		super();		origine = noeud1;		extremite = noeud2;		numRel++;		setLabel(nom);		setWidthLabel(fm.stringWidth(getLabel()));		setHeightLabel(fm.getHeight());		init();	}	// Initialisation	protected void init() {		if(getLabel() == null) setLabel("");		posLien = 0;		origine.addRelationDepart(this);		extremite.addRelationArrive(this);		hideLabel();		showArrow = false;		forme = 0;		selected = false;	}	public static void setBackgroundColor(Color c) {		//System.out.println("setBackgroundColor");		backgroundColor = c;	}	public boolean getSelected() {		return selected;	}	public void setSelected(boolean b) {		this.selected = b;	}	public boolean getClicked() {		return false;	}	public void setClicked(boolean b) {	}	// Méthodes d'acc?s	public Noeud origine() {return origine; }	public Noeud extremite() {return extremite; }	public void setOrigine(Noeud unNoeud) {origine = unNoeud; }	public void setExtremite(Noeud unNoeud) {extremite = unNoeud; }	public String labelOrigine() {return origine().getLabel(); }	public String labelExtremite() {return extremite().getLabel(); }	public int widthLabel() {		if ((show) && (getLabel() != null )) {			return super.widthLabel();		}		else return 0;	}	public void setShowArrow(boolean b) {		this.showArrow = b;	}	public void calculDimension(FontMetrics fm) {		if(fm != null) {			setWidthLabel(fm.stringWidth(getLabel()));			setHeightLabel(fm.getHeight());			widthArrow = fm.getHeight()*2;			//System.out.println(widthArrow);		}	}	// Méthodes	public void setForme(int i) {		this.forme = i;	}	public int posLien() {return posLien;}	public void setPosLien(int i) {posLien = i;}	public boolean lieA(Noeud unNoeud) {		return ((origine() == unNoeud) || (extremite() == unNoeud)) ;	}	public int supGaucheX() {		return 1 + Math.min(origine().supGaucheX(), extremite().supGaucheX()) ;	}	public int supGaucheY() {		return 1 + Math.min(origine().supGaucheY(), extremite().supGaucheY());	}	public Point supGauche() {		return (new Point(supGaucheX(), supGaucheY()));	}	public int infDroitX() {		return 1 + Math.max(origine().infDroitX(), extremite().infDroitX());	}	public int infDroitY() {		return 1 + Math.max(origine().infDroitY(), extremite().infDroitY());	}	public Point infDroit() {		return (new Point(infDroitX(), infDroitY()));	}	public int width() {		return infDroitX() - supGaucheX();	}	public int height() {		return infDroitY() - supGaucheY();	}	public Rectangle rect() {		if ((! showed()) &&  (getLabel()!= null ))			 return new Rectangle(supGaucheX()-widthArrow/2, supGaucheY()-widthArrow/2, width()+1+widthArrow/2, height() + 1+widthArrow/2) ;		else return new Rectangle(supGaucheX() - super.widthLabel(), supGaucheY() - heightLabel(), width() + 2*super.widthLabel(), height() + 2*heightLabel()) ;	}/**	* Pour dessiner la fl?che	* (x1, y1) : coordonnées du point d'origine	* (x2, y2) : coordonnées du point destination*/	public void paintArrow(Graphics g,int x1, int y1, int x2, int y2) {			int l = widthArrow; // La largeur de la fl?che			double xd1 = (double) x1 - x2;			double yd1 = (double) y1 - y2;			double tempo = Math.sqrt(2.0)/2.0;			double d = Math.sqrt((xd1*xd1)+(yd1*yd1));			int x = (int) (x2 + (l * tempo * (xd1*Math.cos(angleArrow) - yd1*Math.sin(angleArrow)))/d);			int y = (int) (y2 + (l * tempo * (yd1*Math.cos(angleArrow) + xd1*Math.sin(angleArrow)))/d);			int x3 = (int) (x2 + (l * tempo * (xd1*Math.cos(angleArrow) + yd1*Math.sin(angleArrow)))/d);			int y3 = (int) (y2 + (l * tempo * (yd1*Math.cos(angleArrow) - xd1*Math.sin(angleArrow)))/d);				int arrowhead_x[] = { x2, x, x3, x2 };				int arrowhead_y[] = { y2, y, y3, y2 };				Color c = g.getColor();				g.setColor(Color.white);				g.fillPolygon(arrowhead_x, arrowhead_y, 4);				g.setColor(c);				g.drawPolygon(arrowhead_x, arrowhead_y, 4);	}		// Pour se dessiner	public void paint(Graphics g, int xRel, int yRel) {		if(forme == FORME_DROITE) paint1(g, xRel, yRel);		if(forme == FORME_ESCALIER) paint2(g, xRel, yRel);	}	protected int getDecalage2dPoint() {		Rectangle r = origine.rect2();		if(origine.affAttributs()) r.add(origine.attributs().rect());		return origine.supGaucheX() + r.width + 2;	}/**	* Relation dessinée en forme droite*/	public void paint1(Graphics g, int xRel, int yRel) {		FontMetrics fm = g.getFontMetrics();		int x1, y1, x2, y2;		if(posLien == 0) {			x1 = origine().infDroitX();			y1 = origine.infDroitY() - origine.height()/2;			x2 = extremite().supGaucheX();			y2 = extremite().supGaucheY() + origine.height()/2;		}		else {			x1 = origine().supGaucheX() + origine().width()/2;			y1 = origine.infDroitY();			x2 = extremite().supGaucheX() + extremite().width()/2;			y2 = extremite().supGaucheY();		}	// On double le trait		g.setColor(Color.lightGray);		if(getSelected()) g.setColor(shadow_color.brighter());		g.drawLine(x1+xRel, y1+yRel+1, x2+xRel, y2+yRel+1);		if(getSelected()) g.setColor(shadow_color);		else {			if (bgColor() == null) g.setColor(normal_color) ;			else g.setColor(bgColor()) ;		}		g.drawLine(x1+xRel, y1+yRel, x2+xRel, y2+yRel);		if(getSelected()) g.setColor(Color.black);		// affichage du label		if ((show) && (getLabel() != null))	{			g.drawString(getLabel(), xRel+((x1 + x2)/2) - super.widthLabel()/2, yRel+((y1 + y2)/2)-heightLabel()/2);		}		// Dessin de la fleche		if (showArrow) {			paintArrow(g, xRel+x1, yRel+y1, xRel+x2, yRel+y2);		}	} // fin paint/**	* Relation dessinée en escalier*/	public void paint2(Graphics g, int xRel, int yRel) {		if (bgColor() == null) g.setColor(normal_color) ;		else g.setColor(bgColor()) ;		//g.setColor(backgroundColor);		FontMetrics fm = g.getFontMetrics();		if(getSelected()) g.setColor(shadow_color);		int x1, y1, x2, y2, x3, y3, x4, y4;		if(posLien == 0) {// Positionnement horizontal des liens			//Rectangle rAtt = null;			//int decalAttX = 0;// Premier point			x1 = origine().infDroitX(); 						// origine en x			y1 = origine().infDroitY() - origine().height()/2; 	// origine en y// 2de point			if(decalage2dPoint) {				x2 = getDecalage2dPoint();				//x2 = origine.supGaucheX() + rAtt.width;				/*rAtt = origine().rect();				Rectangle rNoeud = origine().rect2();				decalAttX =  (rAtt.x + rAtt.width) - (rNoeud.x + rNoeud.width) - 10;				//decalAttX =  rAtt.width - rNoeud.x + rNoeud.width;				if (decalAttX<0) decalAttX = 0;*/			}			else x2 = x1 + (extremite().supGaucheX() - x1) / 4; // point intermediaire en x			//if((decalage2dPoint)&&(x2 < (rAtt.x + rAtt.width))) x2 = x1 + decalAttX;			y2 = y1;											// point intermediaire en y			x3 = x2;											// point intermediaire 2 en x			y3 = extremite().supGaucheY() + origine.height()/2; // intermediaire 2 en y			x4 = extremite().supGaucheX();						// extremite en x			y4 = y3;											// extremite en y		}		else {//Positionnement vertical des liens			x1 = origine().supGaucheX() + origine().rect2().width/2; 	// origine en x			y1 = origine().infDroitY(); 						// origine en y			x2 = x1;	 										// point intermediaire en x			y2 = y1 + (extremite().supGaucheY() - y1) / 4;												// point intermediaire en y			x3 = extremite().supGaucheX() + extremite.rect2().width/2;											// point intermediaire 2 en x			y3 = y2; 											// intermediaire 2 en y			x4 = x3;											// extremite en x			y4 = extremite().supGaucheY();						// extremite en y		}// On double le trait		if(doubleTrait) {			if(getSelected()) g.setColor(shadow_color.brighter());			else g.setColor(Color.lightGray);			g.drawLine(x1+xRel, y1+yRel+1, x2+xRel, y2+yRel+1);			g.drawLine(x2+xRel+1, y2+yRel, x3+xRel+1, y3+yRel);			g.drawLine(x3+xRel, y3+yRel+1, x4+xRel, y4+yRel+1);			if(getSelected()) g.setColor(shadow_color);			else {				if (bgColor() == null) g.setColor(normal_color) ;				else g.setColor(bgColor()) ;			}		}			// Dessin de la ligne brisee			g.drawLine(x1+xRel, y1+yRel, x2+xRel, y2+yRel);			g.drawLine(x2+xRel, y2+yRel, x3+xRel, y3+yRel);			g.drawLine(x3+xRel, y3+yRel, x4+xRel, y4+yRel);			// Dessin de la fleche			if (showArrow) paintArrow(g, xRel+x3, yRel+y3, xRel+x4, yRel+y4);			//if(getSelected()) g.setColor(Color.black);			g.setColor(Color.black);			//else g.setColor(normal_color);			// affichage du label			if ((showed()) && (getLabel() != null))	{				if(x3 < x4) g.drawString(getLabel(), xRel+x3 + 3 , yRel+y3 - 2);				else g.drawString(getLabel(), xRel+x3 - super.widthLabel() - 3, yRel+y3 - 2);			}	} // fin paint2} // fin classe Relation