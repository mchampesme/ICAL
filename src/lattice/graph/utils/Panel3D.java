/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.utils;/**	* IKBS - Editeur des cas	* Définition de Panel3D, sous classe de Panel	* Version 1.0	* David Grosser - 17 Février 1997*/import java.awt.Component;import java.awt.Graphics;public class Panel3D extends IkbsPanel {	public static final int WITH_ALL = 0;	public static final int WITHOUT_TOP = 1;	public static final int WITHOUT_LEFT = 2;	public static final int WITHOUT_RIGHT = 3;	public static final int WITHOUT_BOTTOM = 4;	public static final int NOTHING = 5;/** 	* détermine si la bordure est dessinée compl?tement, partiellement horizontale ou partiellement verticale*/	int choix;/**	* détermine si la longueur de la bordure qui n'est pas dessiné*/	int longueur;/**	* Determine la position de départ de la zone à ne pas dessiner*/	int index;	public Panel3D() {		super();		this.choix = WITH_ALL;	}	public Panel3D(int choix) {		super();		this.choix = choix;		this.index = 0;		this.longueur = 0;	}/**	* Construction d'un Panel3D avec une partie du bord non dessiné*/	public Panel3D(int choix, int index, int longueur) {		super();		this.choix = choix;		this.index = index;		this.longueur = longueur;	}	public Panel3D(int choix, Component c) {		this(choix, 0, (int) c.getSize().height);		//System.out.println(c.getSize());	}/**	* Dessin du panel*/	public synchronized void paint(Graphics g) {		switch(choix) {			case WITH_ALL: paintComplet(g); break;			case WITHOUT_TOP: paintWithoutTop(g); break;			case WITHOUT_LEFT: paintWithoutLeft(g); break;			case WITHOUT_RIGHT: paintWithoutRight(g); break;			case WITHOUT_BOTTOM: paintWithoutBottom(g); break;			case NOTHING: super.paint(g);			default: super.paint(g); break;		}	}/** Affectation de la longeur de la bordure non dessinée */	public void setLongueur(int longueur) {		this.longueur = longueur;	}/** retourne la longueur de la bordure non dessinée */	public int getLongeur() {		return this.longueur;	}/**	* Affectation de l'index de la bordure non dessinée*/	public void setIndex(int index) {		this.index = index;	}/**	* retourne l'index*/	public int getIndex() {		return index;	}/**	* On dessine compl?tement la bordure du Panel 3D*/	public synchronized void paintComplet(Graphics g) {		int w = getSize().width;		int h = getSize().height;		// Dessine le TOP		paintTop(g, w, h);		// Dessine le LEFT		paintLeft(g, w, h);		// Dessine le BOTTOM		paintBottom(g, w, h);		// Dessine le RIGHT		paintRight(g, w, h);	}/**	* On ne dessine que partiellement la bordure du Panel	* Bordure supérieur manquante*/	public void paintWithoutTop(Graphics g) {		int w = getSize().width;		int h = getSize().height;		paintLeft(g, w, h);		paintRight(g, w, h);		paintBottom(g, w, h);		if(longueur != 0) paintTop(g, w, h, index, longueur);	}	public void paintWithoutLeft(Graphics g) {		int w = getSize().width;		int h = getSize().height;		paintTop(g, w, h);		paintBottom(g, w, h);		paintRight(g, w, h);		if(longueur != 0) paintLeft(g, w, h, index, longueur);	}	public synchronized void paintWithoutRight(Graphics g) {		int w = getSize().width;		int h = getSize().height;		paintTop(g, w, h);		paintLeft(g, w, h);		paintBottom(g, w, h);		if(longueur != 0) paintRight(g, w, h, index, longueur);	}	public synchronized void paintWithoutBottom(Graphics g) {		int w = getSize().width;		int h = getSize().height;		paintTop(g, w, h);		paintLeft(g, w, h);		paintRight(g, w, h);		if(longueur != 0) paintBottom(g, w, h, index, longueur);	}	// Dessine le relief supérieur	public synchronized void paintTop(Graphics g, int w, int h) {		g.setColor(getBackground().brighter());		g.drawLine(0, 0, w-1, 0);	}	public synchronized void paintTop(Graphics g, int w, int h, int index, int longueur) {		g.setColor(getBackground().brighter());		g.drawLine(0, 0, index, 0);		g.drawLine(0, index+longueur, 0, w-1);	}	// Dessine le relief de gauche	public synchronized void paintLeft(Graphics g, int w, int h) {		g.setColor(getBackground().brighter());		g.drawLine(0, 0, 0, h-2);	}	public synchronized void paintLeft(Graphics g, int w, int h, int index, int longueur) {		g.setColor(getBackground().brighter());		g.drawLine(0, 0, 0, index);		g.drawLine(0, index+longueur, 0, h);	}	// Dessine le relief du bas	public synchronized void paintBottom(Graphics g, int w, int h) {		g.setColor(getBackground().darker());		g.drawLine(0, h-2, w-2, h-2);		g.setColor((getBackground().darker()).darker());		g.drawLine(0, h-1, w, h-1);	}	public synchronized void paintBottom(Graphics g, int w, int h, int index, int longueur) {		g.setColor(getBackground().darker());		g.drawLine(1, h-2, index, h-2);		g.drawLine(index+longueur, h-2, w-2, h-2);		g.setColor((getBackground().darker()).darker());		g.drawLine(0, h-1, index, h-1);		g.drawLine(index+longueur, h-1, w, h-1);	}	// Dessine le relief de droite	public synchronized void paintRight(Graphics g, int w, int h){		g.setColor(getBackground().darker());		g.drawLine(w-2, 1, w-2, h-2);		g.setColor((getBackground().darker()).darker());		g.drawLine(w-1, 0, w-1, h-1);	}	public synchronized void paintRight(Graphics g, int w, int h, int index, int longueur) {		g.setColor(getBackground().darker());		if(index != 0) g.drawLine(w-2, 1, w-2, index);		g.drawLine(w-2, index+longueur, w-1, index+longueur);		g.drawLine(w-2, index+longueur, w-2, h-2);		g.setColor((getBackground().darker()).darker());		if(index != 0) g.drawLine(w-1, 0, w-1, index);		g.drawLine(w-1, index+longueur+1, w-1, h-1);	}}