/*
 ***********************************************************************
 * Copyright (C) 2004 The Galicia Team 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA; or visit the following url:
 * http://www.gnu.org/copyleft/lesser.html
 *
 ***********************************************************************
 */

package lattice.graph.utils;// import awtimport java.applet.Applet;import java.applet.AppletContext;import java.awt.Component;import java.awt.Image;import java.awt.MediaTracker;import java.awt.Toolkit;import java.io.BufferedInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;import java.util.Enumeration;import java.util.Hashtable;import java.util.Vector;/**	* IKBS v2.3	* Permet de charger des ressources graphiques, de les stocker dans une table de hashage	* statique, afin de les retrouver rapidemment	* @author David Grosser	* @date 18 Mars 1999	* @since 18 Mars 1999*/public class Resources extends Object {// Variables de classe	//public static String navigator = "Explorer";	public static String directory = "Ressources";	public static String dirSeparator = "/";	public static String defautDocBase = "http://www.univ-reunion.fr/~ikbs/";	protected static Applet applet;// Doit-?tre initialisée au démarrage de l'environnement	protected static Hashtable images = new Hashtable();	protected static Toolkit toolkit;	protected static URL docBase;// Param?tres d'acc?s à la ressource	public static int URL_DIR 	= 0; 	// Chargement de la ressource a partir de l'url de base et du directory	public static int URL_SANSDIR 	= 1; 	// Chargement de la ressource a partir de l'url de base et du directory relatif	public static int SANS_URL 	= 2; 	// Chargement de la Ressource à partir du chemin d'acc?s complet au fichier	public static int FROM_JAR 	= 3; 	// Chargement de ressources contenues dans un jar// Param?tre d'acc?s au mode de gestion mémoire	//public static int LOW = 0; 	// Pas de stockage en mémoire des images	//public static int MEDIUM = 1; // Stockage de l'image dans la table de Hashage locale	//public static int HIGH = 2; 	// Les images chargées sont stockées dans la table globale jusqu'à fin de l'application	public String defautJarDirectory = "ikbs/ressources";	// Variables d'instances	protected Component pere;	protected MediaTracker mediaTracker;	protected int acces = URL_DIR; // par défaut, on acc?de à la ressource via l'url et le nom du directory	protected Hashtable imagesLocales = new Hashtable(); // Table de Hashage locale. Les images sont conservées jusqu'à la mort de l'instance si on est en mode local	protected boolean local = false; // Type de stockage en mémoire des images (statique ou dynamique)	protected boolean accesDistant = false; // true : si la ressource n'est pas trouvée en locale, on la cherche sur la liste des serveurs disponibles.	public boolean wait = true;/**	* Constructeur d'un objet ressource	* par défaut, toute les images chargées à l'aide de cette classe sont gardées dans la table	* de hashage statique des images*/	public Resources(Component pere) {		this.pere = pere;		toolkit = pere.getToolkit();		this.mediaTracker = new MediaTracker(pere);	}/**	* Permet de positionner l'objet Ressource en chargement local des images	* Les images sont stockées dans une table de hashage locale (variable d'instance)*/	public Resources(Component pere, boolean local) {		this(pere);		this.local = local;		//if(local) imagesLocales = new Hashtable();	}/**	* Il est important d'appeler ce constructeur la premi?re fois que l'on construit	* un Ressources, de facon a initialiser la variable statique docBase*/	public Resources(Applet applet) {		this((Component) applet);		Resources.applet = applet;		Resources.docBase = applet.getDocumentBase();		//setDocBase(applet.getDocumentBase());		//setAppletContext(applet.getAppletContext());	}	public int getAcces() {		return acces;	}	public void setAcces(int a) {		acces = a;	}	public boolean getAccesDistant() {		return accesDistant;	}	public void setAccesDistant(boolean a) {		accesDistant = a;	}	public static AppletContext getAppletContext() {		if(applet != null) return applet.getAppletContext();		else {			System.out.println("Impossible d'acc?der au contexte de l'applet");			return null;		}	}	public static URL getDocBase() {		//URL u = null;		//if(applet != null) u = applet.getDocumentBase();		//else System.out.println("Impossible d'acc?der à l'URL de base");		if(docBase == null) {			try {				URL u = new URL(defautDocBase);				return u;			}			catch(MalformedURLException e) {				System.out.println("Impossible d'acc?der à l'URL de base");				return null;			}		}		return docBase;	}	public static String getDefautDocBase() {		return defautDocBase;	}	public static Toolkit getToolkit() {		return toolkit;	}/**	* Pour charger un ensemble d'images	* Les images sont chargées à partir du chemin d'acc?s relatif (à partir du docBase)	* Les images chargées sont stockées dans la table de Hashage de la classe Ressources (variable statique)*/	public void init(String nomImages[]) throws MalformedURLException, InterruptedException {		for(int i=0; i<nomImages.length; i++) {			if(get(nomImages[i]) == null) {				//System.out.println("on charge l'image "+nomImages[i]);				addImage(nomImages[i], i);			}		}		loadImages();	}	public void init(Vector nomImages) throws MalformedURLException, InterruptedException {		for(int i=0; i<nomImages.size(); i++) {			if(get((String) nomImages.elementAt(i)) == null) {				//System.out.println("on charge l'image "+(String) nomImages.elementAt(i));				addImage((String) nomImages.elementAt(i), i);			}		}		loadImages();	}	public void init(String nomImage) throws MalformedURLException, InterruptedException, OutOfMemoryError {		if(get(nomImage) == null) {			addImage(nomImage, 0);			loadImages();		}	}	public static String getParameter(String s) {		if(applet != null) return applet.getParameter(s);		else {			System.out.println("Impossible d'acc?der aux param?tres de l'applet");			return null;		}	}/*	public void addImage(String nomImage, int i) throws MalformedURLException, InterruptedException {		if(get(nomImage) == null) {			InputStream inputstream = null;			if(acces == FROM_JAR) {				//System.out.println("On acc?de à : "+"/"+defautJarDirectory+"/"+nomImage);				//inputstream = ClassLoader.getSystemResourceAsStream("/"+defautJarDirectory+"/"+nomImage);				inputstream = getClass().getResourceAsStream("/"+defautJarDirectory+"/"+nomImage);			}			else inputstream = getClass().getResourceAsStream("/"+nomImage);		 	if(inputstream == null) {		 		if(getAccesDistant()) {					urlImage(nomImage, i);					System.out.println("Chargement de la ressource "+nomImage+" à partir d'un url");				}			}			else {				if( ! (unjarImage(nomImage, inputstream))) {					if(getAccesDistant()) {						System.out.println("Chargement de la ressource "+nomImage+" à partir d'un url");						urlImage(nomImage, i);					}				}				else {					//System.out.println("Chargement de la ressource "+nomImage+" à partir d'un jar");				}			}		}	}*/	public void addImage(String nomImage, int i) throws MalformedURLException, InterruptedException {		if(get(nomImage) == null) {			InputStream inputstream = null;			if(acces == FROM_JAR) {				inputstream = getClass().getResourceAsStream("/"+defautJarDirectory+"/"+nomImage);				if( ! (unjarImage(nomImage, inputstream))) {					if(getAccesDistant()) {						//System.out.println("Chargement de la ressource "+nomImage+" à partir d'un url");						urlImage(nomImage, i);					}				}			}		 	else {				urlImage(nomImage, i);				//System.out.println("Chargement de la ressource "+nomImage+" à partir d'un url");			}		}	}/**	* Charger les images à partir d'un URL*/	protected void urlImage (String nomImage, int i) throws MalformedURLException, InterruptedException {		URL u = buildURL(nomImage);		if(u != null) {			Image img = toolkit.getImage(u);			if(wait) mediaTracker.addImage(img, i);			put(nomImage, img); // On met l'image chargée dans la table images		}	}/**	* Charger les ressources à partir d'un jar*/	public boolean unjarImage (String nomImage, InputStream inputstream) {	  try{		BufferedInputStream bufferedinputstream = new BufferedInputStream(inputstream);		ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream(1024);	    byte abyte0[] = new byte[1024];        int i;		while((i = bufferedinputstream.read(abyte0)) > 0) bytearrayoutputstream.write(abyte0, 0, i);		bufferedinputstream.close();		bytearrayoutputstream.flush();		abyte0 = bytearrayoutputstream.toByteArray();		if(abyte0.length == 0) {			return false;		}		else {			Image img = toolkit.createImage(abyte0);			put(nomImage, img);			return true;		}	   } catch(IOException ioexception) {	   	 	return false;	   	 }	}/**	* Sauvegarde de l'image dans la table de hashage locale ou statique*/	public void put(String nomImage, Image img) {		if(local) imagesLocales.put(nomImage, img);		else images.put(nomImage, img);	}/**	* Récupération de l'image nomImage dans la table locale ou statique*/	public Image get(String nomImage) {		Image img = null;		if(local) {			img = (Image) imagesLocales.get(nomImage);// On regarde si l'image se trouve dans la table locale			if(img == null) {				img = (Image) images.get(nomImage);// A tout hasard, elle se trouve peut-?tre dans la table globale ?				if(img != null) System.out.println(nomImage+" trouvée dans la table globale");			}		}		else img = (Image) images.get(nomImage);		return img;	}/**	* Transférer les images de la table locale vers la table globale*/	public void copyLocal() {		Image img = null;		for (Enumeration e = imagesLocales.keys(); e.hasMoreElements();) {        	String nomImage = (String) e.nextElement();        	//System.out.println("Transfert de :"+nomImage);        	img = (Image) imagesLocales.get(nomImage);        	if(img != null) images.put(nomImage, img);        }	}/**	* Trouver la clef d'une image dans la table*/	public String find(Image img) {		Image m = null;		for (Enumeration e = imagesLocales.keys(); e.hasMoreElements();) {			String clef = (String) e.nextElement();			m = get(clef);			if(m == null) {				//System.out.println("On efface "+clef);				removeImage(clef); // On efface les entrées null			}			else {				if(img == get(clef)) {					//System.out.println(clef+" trouvée");					return clef;				}			}		}		return null;	}/**	* Mode statique ou dynamique	* En mode statique, les images sont stockées dans la table de hashage statique donc accessible à postériori par Ressources.getStaticImage(nomImg)	* En mode dynamique, les images sont accessibles via l'instance de Ressources*/	public boolean getLocal() {		return local;	}/**	* Affectation du mode local ou global*/	public void copyLocal(boolean b) {		if(local != b) {			local = b;			if(! b) {// On passe du mode local au global				copyLocal();// Copie des images locales en global			}		}	}/**	* Affectation de la variable local*/	public void setLocal(boolean b) {		local = b;	}/**	* Affichage de la liste des images conservées*/	public void toPrint() {		System.out.println("Liste des images en mémoire statique :\n");		for(Enumeration e = images.keys(); e.hasMoreElements();) {			System.out.println(e.nextElement());			//s += new String((String) e.nextElement()+"\n");		}		System.out.println("Liste des images en mémoire dynamique :\n");		for(Enumeration e = imagesLocales.keys(); e.hasMoreElements();) {			System.out.println(e.nextElement());		}		//return s;	}/**	* Efface l'entrée pour @param (statique)*/	public static void removeStaticImage(String nomImage) {		images.remove(nomImage);	}/**	* Efface l'entrée pour @param*/	public void removeImage(String nomImage) {		if(local) {			//System.out.println("On efface "+nomImage+" des ressources");			Image img = get(nomImage);			imagesLocales.remove(nomImage);			//if(img != null) img.flush();			//toPrint();		}		else images.remove(nomImage);	}/**	* Efface un Vecteur d'images*/	public void removeImages(Vector nomImages) {		for(int i=0; i<nomImages.size(); i++) {			images.remove((String) nomImages.elementAt(i));			//System.out.println("Efface : "+nomImages.elementAt(i));		}		/*for(Enumeration e = images.keys(); e.hasMoreElements();) {			System.out.println("Il reste : "+e.nextElement());		}*/	}/**	* Efface un objet image des tables, s'il est présent*/	public void removeImage(Image img) {		String nomImg = find(img);		if(nomImg != null) removeImage(nomImg);	}/**	* Efface une Enumeration d'images*/	public void removeImages(Enumeration e) {		for(; e.hasMoreElements();) {			images.remove((String) e.nextElement());		}	}/**	* Permet de construire l'URL*/	protected URL buildURL(String nomImage) throws MalformedURLException {		URL docBase = getDocBase();		URL u = null;		if(acces == URL_DIR) {			u = new URL(docBase, directory+dirSeparator+nomImage);			//System.out.println("URL_DIR : "+u);		}		if(acces == URL_SANSDIR) {			u = new URL(docBase, nomImage);			//System.out.println("docbase : "+docBase+" nomImages : "+nomImage);			//System.out.println("URL_SANSDIR : "+u);			//return u;		}		if(acces == SANS_URL) {			u = new URL("file://"+nomImage);			//System.out.println("SANS_URL : "+u);		}		try {			u.openStream();		}catch(IOException e) {			if(getAccesDistant()) {				showAll("Ressource non accessible a l'URL : "+u+", test sur "+defautDocBase);				u = new URL(new URL(defautDocBase), nomImage);			}			else {				//showAll("Impossible de charger la ressource :"+u);				u = null;			}		  }		return u;	}	protected static URL buildStaticURL(String ress) throws MalformedURLException {		URL u = new URL(getDocBase(), ress);		try {			u.openStream();		}catch(IOException e) {			showAll("Ressource non accessible a l'URL : "+u);			//u = new URL(new URL(defautDocBase), ress);		  }		return u;	}	public void loadImages() throws InterruptedException {		if(wait) mediaTracker.waitForAll();	}	public static Image getStaticImage(String nomImage) {		return (Image) images.get(nomImage);	}	public Image getImage(String nomImage) {		Image img = null;			try {				init(nomImage);				img = get(nomImage);			}	catch (Exception e) {					//System.out.println("Attention : "+nomImage+" invalide ou probl?me de mémoire");				}		 return img;	}	public MediaTracker getMediaTracker() {		return mediaTracker;	}/**	* Pour charger une image qui ne sera pas gardée dans la table de Hashage statique	* Elle sera conservée uniquement dans la table locale*//*	public Image getTempoImage(String nomImage) {		Image img = null;			try {				if(get(nomImage) == null) {					//URL u = buildURL(directory+separateur+nomImage);					URL u = buildURL(nomImage);					img = toolkit.getImage(u);					mediaTracker.addImage(img, 0);					loadImages();				}			}catch (Exception e) {}		//}		 return img;	}*//**	* Modification du nom de repertoire de ressources*/	public void setDirectory(String dir) {		directory = dir;	}/**	* Permet d'afficher une page Web	* @param url l'adresse de la page à afficher*/	public static void showDocument(String url) {	 if((url != null)&&(! url.equals(""))) {		URL u = null;		try {			if((new String("http://").indexOf(url) != -1)||(new String("file:/").indexOf(url) != -1)) u = new URL(url);// La string commence par http ou file:/			else u = buildStaticURL(url);		}catch (MalformedURLException e) {showAll("Erreur : acc?s aux ressources invalide");}		System.out.println(u);		getAppletContext().showDocument(u, "Illustrations");	 }	 else {	 	showAll("Pas d'URL associé à cet élément");	 }	}	public static void showStatus(String s) {		getAppletContext().showStatus(s);	}	public static void showAll(String s) {		System.out.println(s);		showStatus(s);	}}